<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python_MySQL数据库]]></title>
    <url>%2F2019%2F04%2F17%2FPython-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[MySQLMySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。 安装 安装教程查看链接Windows 上安装 MySQL MySQL常用命令以管理员身份打开cmd命令行工具，切换到你安装的mysql目录，这里是： 1D:\Mysql\mysql-8.0.15-winx64\bin 启动： 1net start mysql 登录 1mysql -h 主机名 -u 用户名 -p 如果是登录本机MySQL数据库，只需要输入以下命令：1mysql -u root -p 接下来会让你输入登录密码：输入即可，如图所示： 参数说明·： -h : 指定客户端所要登录的 MySQL 主机名(IP), 登录本机(localhost 或 127.0.0.1)该参数可以省略; -u : 登录的用户名; -p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。 退出和停止 123quit;//或者 exit...net stop mysql 修改密码 1mysqladmin -u用户名 -p旧密码 password 新密码 创建数据库 1create database &lt;数据库名&gt;; 显示数据库 1show databases; 注意：最后有个s 删除数据库 1drop database &lt;数据库名&gt; 如图所示： 更多常用命令访问：MySQL常用命令大全 mysql-connector使用 mysql-connector 来连接使用 MySQL， mysql-connector 是 MySQL 官方提供的驱动器。 安装我们可以使用 pip 命令来安装 mysql-connector：1python -m pip install mysql-connector 或者直接在pycharm的setting里面安装mysql-connect包 操作创建数据库连接123456789import mysql.connector mydb = mysql.connector.connect( host="localhost", # 数据库主机地址 user="username", # 数据库用户名 passwd="password" # 数据库密码) print(mydb) 创建数据库创建数据库使用 “CREATE DATABASE” 语句，我们创建一个名为 first_db 的数据库： 1234567891011import mysql.connector mydb = mysql.connector.connect( host="localhost", user="root", passwd="123456") mycursor = mydb.cursor() mycursor.execute("CREATE DATABASE first_db") 查看数据库输出所有数据库列表：1234567891011121314import mysql.connector mydb = mysql.connector.connect( host="localhost", user="root", passwd="123456") mycursor = mydb.cursor() mycursor.execute("SHOW DATABASES") for x in mycursor: print(x) 我们可以直接连接数据库，如果数据库不存在，会输出错误信息： 12345678import mysql.connector mydb = mysql.connector.connect( host="localhost", user="root", passwd="123456", database="runoob_db") 创建数据表1234567891011import mysql.connector mydb = mysql.connector.connect( host="localhost", user="root", passwd="123456", database="first_db" # 确保数据库first_db已存在)mycursor = mydb.cursor() mycursor.execute("CREATE TABLE sites (name VARCHAR(255), url VARCHAR(255))") 查看数据表是否已存在：1234567891011121314import mysql.connector mydb = mysql.connector.connect( host="localhost", user="root", passwd="123456", database="first_db")mycursor = mydb.cursor() mycursor.execute("SHOW TABLES") for x in mycursor: print(x) 主键设置创建表的时候我们一般都会设置一个主键（PRIMARY KEY）,主键起始值为 1，逐步递增。 如果我们的表已经创建，我们需要使用 ALTER TABLE 来给表添加主键： 12345678910111213给 sites 表添加主键。import mysql.connector mydb = mysql.connector.connect( host="localhost", user="root", passwd="123456", database="first_db")mycursor = mydb.cursor() mycursor.execute("ALTER TABLE sites ADD COLUMN id INT AUTO_INCREMENT PRIMARY KEY") 如果你还未创建 sites 表，可以直接使用以下代码创建。 给表创建主键。123456789101112import mysql.connector mydb = mysql.connector.connect( host="localhost", user="root", passwd="123456", database="first_db")mycursor = mydb.cursor() mycursor.execute("CREATE TABLE sites (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255), url VARCHAR(255))") 插入数据 向 sites 表插入一条记录。 1234567891011121314151617import mysql.connector mydb = mysql.connector.connect( host="localhost", user="root", passwd="123456", database="first_db")mycursor = mydb.cursor() sql = "INSERT INTO sites (name, url) VALUES (%s, %s)"val = ("RUNOOB", "https://www.runoob.com")mycursor.execute(sql, val) mydb.commit() # 数据表内容有更新，必须使用到该语句 print(mycursor.rowcount, "记录插入成功。") 执行代码，输出结果为：11 记录插入成功 批量插入批量插入使用 executemany() 方法，该方法的第二个参数是一个元组列表，包含了我们要插入的数据： 向 sites 表插入多条记录。1234567891011121314151617181920212223import mysql.connector mydb = mysql.connector.connect( host="localhost", user="root", passwd="123456", database="first_db")mycursor = mydb.cursor() sql = "INSERT INTO sites (name, url) VALUES (%s, %s)"val = [ ('Google', 'https://www.google.com'), ('Github', 'https://www.github.com'), ('Taobao', 'https://www.taobao.com'), ('stackoverflow', 'https://www.stackoverflow.com/')] mycursor.executemany(sql, val) mydb.commit() # 数据表内容有更新，必须使用到该语句 print(mycursor.rowcount, "记录插入成功。") 执行代码，输出结果为：124 记录插入成功。` 如果我们想在数据记录插入后，获取该记录的 ID ，可以使用以下代码：12345678 sql = "INSERT INTO sites (name, url) VALUES (%s, %s)"val = ("Zhihu", "https://www.zhihu.com")mycursor.execute(sql, val) mydb.commit() print("1 条记录已插入, ID:", mycursor.lastrowid) 执行代码，输出结果为：11 条记录已插入, ID: 6 查询数据 查询所有数据123456mycursor.execute("SELECT * FROM sites") myresult = mycursor.fetchall() # fetchall() 获取所有记录 for x in myresult: print(x) 执行代码，输出结果为：123456(1, &apos;RUNOOB&apos;, &apos;https://www.runoob.com&apos;)(2, &apos;Google&apos;, &apos;https://www.google.com&apos;)(3, &apos;Github&apos;, &apos;https://www.github.com&apos;)(4, &apos;Taobao&apos;, &apos;https://www.taobao.com&apos;)(5, &apos;stackoverflow&apos;, &apos;https://www.stackoverflow.com/&apos;)(6, &apos;Zhihu&apos;, &apos;https://www.zhihu.com&apos;) 也可以读取指定的字段数据：123456mycursor.execute("SELECT name, url FROM sites") myresult = mycursor.fetchall() for x in myresult: print(x) 执行代码，输出结果为：123456(&apos;RUNOOB&apos;, &apos;https://www.runoob.com&apos;)(&apos;Google&apos;, &apos;https://www.google.com&apos;)(&apos;Github&apos;, &apos;https://www.github.com&apos;)(&apos;Taobao&apos;, &apos;https://www.taobao.com&apos;)(&apos;stackoverflow&apos;, &apos;https://www.stackoverflow.com/&apos;)(&apos;Zhihu&apos;, &apos;https://www.zhihu.com&apos;) 如果我们只想读取一条数据，可以使用 fetchone() 方法：12345mycursor.execute("SELECT * FROM sites") myresult = mycursor.fetchone() print(myresult) 执行代码，输出结果为：1(1, &apos;RUNOOB&apos;, &apos;https://www.runoob.com&apos;) 如果我们要读取指定条件的数据，可以使用 where 语句：12345678sql = "SELECT * FROM sites WHERE name ='RUNOOB'" mycursor.execute(sql) myresult = mycursor.fetchall() for x in myresult: print(x) 执行代码，输出结果为：1(1, &apos;RUNOOB&apos;, &apos;https://www.runoob.com&apos;) 也可以使用通配符 %：12345678sql = "SELECT * FROM sites WHERE url LIKE '%oo%'" mycursor.execute(sql) myresult = mycursor.fetchall() for x in myresult: print(x) 执行代码，输出结果为：12(1, &apos;RUNOOB&apos;, &apos;https://www.runoob.com&apos;)(2, &apos;Google&apos;, &apos;https://www.google.com&apos;) 为了防止数据库查询发生 SQL 注入的攻击，我们可以使用 %s 占位符来转义查询的条件： 123456789sql = "SELECT * FROM sites WHERE name = %s"na = ("RUNOOB", ) mycursor.execute(sql, na) myresult = mycursor.fetchall() for x in myresult: print(x) 排序查询结果排序可以使用 ORDER BY 语句，默认的排序方式为升序，关键字为 ASC，如果要设置降序排序，可以设置关键字 DESC。 按 name 字段字母的升序排序：12345678sql = "SELECT * FROM sites ORDER BY name" mycursor.execute(sql) myresult = mycursor.fetchall() for x in myresult: print(x) 执行代码，输出结果为：123456(3, &apos;Github&apos;, &apos;https://www.github.com&apos;)(2, &apos;Google&apos;, &apos;https://www.google.com&apos;)(1, &apos;RUNOOB&apos;, &apos;https://www.runoob.com&apos;)(5, &apos;stackoverflow&apos;, &apos;https://www.stackoverflow.com/&apos;)(4, &apos;Taobao&apos;, &apos;https://www.taobao.com&apos;)(6, &apos;Zhihu&apos;, &apos;https://www.zhihu.com&apos;) 降序排序实例：12345678sql = "SELECT * FROM sites ORDER BY name DESC" mycursor.execute(sql) myresult = mycursor.fetchall() for x in myresult: print(x) 执行代码，输出结果为： 123456(6, &apos;Zhihu&apos;, &apos;https://www.zhihu.com&apos;)(4, &apos;Taobao&apos;, &apos;https://www.taobao.com&apos;)(5, &apos;stackoverflow&apos;, &apos;https://www.stackoverflow.com/&apos;)(1, &apos;RUNOOB&apos;, &apos;https://www.runoob.com&apos;)(2, &apos;Google&apos;, &apos;https://www.google.com&apos;)(3, &apos;Github&apos;, &apos;https://www.github.com&apos;) 限制查询的数据量指定起始位置，读取前 3 条记录. 例如，从第二条开始读取前 3 条记录：123456mycursor.execute("SELECT * FROM sites LIMIT 3 OFFSET 1") # 0 为 第一条，1 为第二条，以此类推 myresult = mycursor.fetchall() for x in myresult: print(x) 执行代码，输出结果为：123(2, &apos;Google&apos;, &apos;https://www.google.com&apos;)(3, &apos;Github&apos;, &apos;https://www.github.com&apos;)(4, &apos;Taobao&apos;, &apos;https://www.taobao.com&apos;) 删除记录1234567sql = "DELETE FROM sites WHERE name = 'stackoverflow'" mycursor.execute(sql) mydb.commit() print(mycursor.rowcount, " 条记录删除") 执行代码，输出结果为：11 条记录删除 注意：要慎重使用删除语句，删除语句要确保指定了 WHERE 条件语句，否则会导致整表数据被删除。 为了防止数据库查询发生 SQL 注入的攻击，我们可以使用 %s 占位符来转义删除语句的条件： 12sql = "DELETE FROM sites WHERE name = %s"na = ("stackoverflow", ) 更新表数据12345678sql = "UPDATE sites SET name = 'ZH' WHERE name = 'Zhihu'" mycursor.execute(sql) mydb.commit() print(mycursor.rowcount, " 条记录被修改")执行代码，输出结果为： 使用 %s 占位符来转义更新语句的条件：12sql = "UPDATE sites SET name = %s WHERE name = %s"val = ("Zhihu", "ZH") 删除表123sql = "DROP TABLE IF EXISTS sites" # 删除数据表 sites mycursor.execute(sql) PyMySQL 驱动PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，Python2中则使用mysqldb。 PyMySQL 遵循 Python 数据库 API v2.0 规范，并包含了 pure-Python MySQL 客户端库。 安装 命令： 1pip install PyMySQL pycharm 的setting里面安装pymysql包 操作在操作之前确保：1.您已经创建了数据库 TESTDB.2.在TESTDB数据库中您已经创建了表 EMPLOYEE3.EMPLOYEE表字段为 FIRST_NAME, LAST_NAME, AGE, SEX 和 INCOME。 数据库连接123456789101112131415161718import pymysql # 打开数据库连接db = pymysql.connect("localhost","testuser","test123","TESTDB" ) # 使用 cursor() 方法创建一个游标对象 cursorcursor = db.cursor() # 使用 execute() 方法执行 SQL 查询 cursor.execute("SELECT VERSION()") # 使用 fetchone() 方法获取单条数据.data = cursor.fetchone() print ("Database version : %s " % data) # 关闭数据库连接db.close() 创建数据库表1234567891011121314151617181920212223import pymysql # 打开数据库连接db = pymysql.connect("localhost","testuser","test123","TESTDB" ) # 使用 cursor() 方法创建一个游标对象 cursorcursor = db.cursor() # 使用 execute() 方法执行 SQL，如果表存在则删除cursor.execute("DROP TABLE IF EXISTS EMPLOYEE") # 使用预处理语句创建表sql = """CREATE TABLE EMPLOYEE ( FIRST_NAME CHAR(20) NOT NULL, LAST_NAME CHAR(20), AGE INT, SEX CHAR(1), INCOME FLOAT )""" cursor.execute(sql) # 关闭数据库连接db.close() 插入操作1234567891011121314151617# 部分代码省略# SQL 插入语句sql = """INSERT INTO EMPLOYEE(FIRST_NAME, LAST_NAME, AGE, SEX, INCOME) VALUES ('Mac', 'Mohan', 20, 'M', 2000)"""try: # 执行sql语句 cursor.execute(sql) # 提交到数据库执行 db.commit()except: # 如果发生错误则回滚 db.rollback() # 关闭数据库连接db.close() 也可以写成如下形式：12345# SQL 插入语句sql = "INSERT INTO EMPLOYEE(FIRST_NAME, \ LAST_NAME, AGE, SEX, INCOME) \ VALUES ('%s', '%s', %s, '%s', %s)" % \ ('Mac', 'Mohan', 20, 'M', 2000) 查询操作Python查询Mysql使用 fetchone() 方法获取单条数据, 使用fetchall() 方法获取多条数据。 fetchone(): 该方法获取下一个查询结果集。结果集是一个对象 fetchall(): 接收全部的返回结果行. rowcount: 这是一个只读属性，并返回执行execute()方法后影响的行数。 查询EMPLOYEE表中salary（工资）字段大于1000的所有数据： 12345678910111213141516171819202122# SQL 查询语句sql = "SELECT * FROM EMPLOYEE \ WHERE INCOME &gt; %s" % (1000)try: # 执行SQL语句 cursor.execute(sql) # 获取所有记录列表 results = cursor.fetchall() for row in results: fname = row[0] lname = row[1] age = row[2] sex = row[3] income = row[4] # 打印结果 print ("fname=%s,lname=%s,age=%s,sex=%s,income=%s" % \ (fname, lname, age, sex, income ))except: print ("Error: unable to fetch data") # 关闭数据库连接db.close() 更新操作将 TESTDB 表中 SEX 为 ‘M’ 的 AGE 字段递增 1： 1sql = "UPDATE EMPLOYEE SET AGE = AGE + 1 WHERE SEX = '%c'" % ('M') 删除操作删除数据表 EMPLOYEE 中 AGE 大于 20 的所有数据：12# SQL 删除语句sql = "DELETE FROM EMPLOYEE WHERE AGE &gt; %s" % (20)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>python</tag>
        <tag>PyMySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Django框架]]></title>
    <url>%2F2019%2F04%2F11%2F%E5%AD%A6%E4%B9%A0Django%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[介绍Django是一个开放源代码的Web应用框架，由Python写成。 安装 pycharm社区版创建django项目：pycharm自带django数据包 项目pycharm创建第一个django请求步骤 在你要创建项目的目录下执行cmd命令1django-admin.py startproject 文件名 执行之后可以看到项目的目录结构1234567hellodjango|-- hellodjango| |-- __init__.py| |-- settings.py| |-- urls.py| `-- wsgi.py`-- manage.py 运行:我们进入 hellodjango 目录(pycharm下，点击 Terminal)，输入以下命令，启动服务器： 1python3 manage.py runserver 127.0.0.1:8000 打开显示的网址()，可以看到第一个django请求运行成功. ####### 目录说明： HelloWorld: 项目的容器。 manage.py: 一个实用的命令行工具，可让你以各种方式与该 Django 项目进行交互。 HelloWorld/init.py: 一个空文件，告诉 Python 该目录是一个 Python 包。 HelloWorld/settings.py: 该 Django 项目的设置/配置。 HelloWorld/urls.py: 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站”目录”。 HelloWorld/wsgi.py: 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目。配置在settings.py文件中修改： 模板路径配置（html） 123456789TEMPLATES = [ &#123; ... 'DIRS': [os.path.join(BASE_DIR,'templates')], # os.path.join(BASE_DIR）表示基目录，你的project目录 # 'templates'表示模板路径 ... &#125;,] 静态文件配置（图片，css文件, js文件） 1234STATIC_URL = &apos;/static/&apos; # 使用时前缀STATICFILES_DIRS=( os.path.join(BASE_DIR,&apos;static&apos;), # 真实路径，干脆直接写成&apos;static&apos;) 注意：逗号不能少！！！ 额外配置（csrf注释） 123456789MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',] 路由关系(url对应关系)url—&gt;函数 注释自带的url(path)，按照自带格式创建你的页面12# path(&apos;admin/&apos;, admin.site.urls), url(r&apos;^login/&apos;,login), 处理请求函数先看整体代码： 123456789101112131415161718192021222324from django.shortcuts import HttpResponse,render,redirectdef login(request): # return HttpResponse('hahahhahahah') # 自动找到模板路径下的html文件，读取类容并返回给用户 print(request.GET) if request.method=="GET": # 模板渲染 return render(request,'login.html') else: # 用户post提交的数据（请求体） u = request.POST.get('username') p = request.POST.get('password') if u=='root'and p=='123123': # 登陆成功,跳转到其他页面 return redirect('https://www.youdao.com/') else: # 登陆失败 return render(request,'login.html',&#123;'msg':'用户名或密码错误'&#125;)urlpatterns = [ # path('admin/', admin.site.urls), url(r'^login/',login),] 步骤说明： 导入包 1from django.shortcuts import HttpResponse,render,redirect 定义函数 123def indox(request): 函数体 request的两种方法（request.method）: request.GET , 从请求头中的url拿到值， GET请求只有request.GET有值 request.POST ,从请求头中拿到值， POST请求request.GET和request.POST都可能有值 request表示用户请求相关的所有信息（对象） 三种返回方式： return HttpResponse（”字符串”），只能在页面上显示支付串 return render(函数参数（request）,’模板路径’（login.html），{})， 自带找到模板路径下的login.html，读取内容并返回给用户，模板路径是templates以后的路径。 return redirect(‘URL’)，跳转到要跳转的网址（可以是其他网站，也可以是自己的网址） 说明：在前面我们已经配置过模板路径和静态文件路径,所以可以直接运用自己web网页设计知识对你的页面进行设计、美化和动态交互，记得在你html文件中要连接css、js或图片文件时，前面添加路径（/static/），例如：1&lt;link rel=&quot;stylesheet&quot; href=&quot;/static/commons.css&quot;/&gt; 模板标签过滤器urls.py123456789def index(request):return render(request,'模板路径‘)，&#123; 'k1':'v1', 'k2':[1,2,32,34],#列表 'k3':&#123;'k1':'v1','k2':'v2',...&#125;,# 字典 'user_list_dict':[&#123;&#125;] ，#列表[字典]&#125;) index.html123&lt;h1&gt;&#123;&#123;k1&#125;&#125;&lt;/h1&gt;&lt;h1&gt;&#123;&#123;k2.2&#125;&#125;&lt;/h1&gt;&lt;h1&gt;&#123;&#123;k3.&#125;&#125;&lt;/h1&gt; 模板过滤器可以在变量被显示前修改它，过滤器使用管道字符，如下所示： 1&#123;&#123; name|lower &#125;&#125; name 变量被过滤器 lower 处理后，文档大写转换文本为小写。 过滤管道可以被 套接 ，既是说，一个过滤器管道的输出又可以作为下一个管道的输入：1&#123;&#123; my_list|first|upper &#125;&#125; 以上实例将第一个元素并将其转化为大写。 有些过滤器有参数。 过滤器的参数跟随冒号之后并且总是以双引号包含。 例如：1&#123;&#123; bio|truncatewords:&quot;30&quot; &#125;&#125; 这个将显示变量 bio 的前30个词。 其他过滤器： addslashes : 添加反斜杠到任何反斜杠、单引号或者双引号前面。 date : 按指定的格式字符串参数格式化 date 或者 datetime 对象，实例： 1&#123;&#123; pub_date|date:&quot;F j, Y&quot; &#125;&#125; length : 返回变量的长度。 说明：django标签通过 ‘.’ 索引 if/else 标签基本语法格式如下： 123&#123;% if condition %&#125; ... display&#123;% endif %&#125; 或者：1234567&#123;% if condition1 %&#125; ... display 1&#123;% elif condition2 %&#125; ... display 2&#123;% else %&#125; ... display 3&#123;% endif %&#125; 根据条件判断是否输出。if/else 支持嵌套。 说明： if 标签接受 and ， or 或者 not 关键字来对多个变量做判断 ，或者对变量取反（ not )。 循环123456&lt;h3&gt;循环&lt;/h3&gt;&lt;ul&gt;&#123;% for item in users%&#125; &lt;li&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; 说明： 可以与html搭配使用 ifequal/ifnotequal 标签 ifequal 标签比较两个值，当他们相等时，显示在 ifequal 和 endifequal 之中所有的值。 下面的例子比较两个模板变量 user 和 currentuser : 123&#123;% ifequal user currentuser %&#125; &lt;h1&gt;Welcome!&lt;/h1&gt;&#123;% endifequal %&#125; 和 if 类似， ifequal 支持可选的 else标签： 12345&#123;% ifequal section 'sitenews' %&#125; &lt;h1&gt;Site News&lt;/h1&gt;&#123;% else %&#125; &lt;h1&gt;No News Here&lt;/h1&gt;&#123;% endifequal %&#125; 注释标签Django 注释使用 。 1&#123;# 这是一个注释 #&#125; include 标签 include 标签允许在模板中包含其它的模板的内容。 下面这个例子都包含了 nav.html 模板：1&#123;% include &quot;nav.html&quot; %&#125; 模板继承模板可以用继承的方式来实现复用。 接下来我们先创建之前项目的 templates 目录中添加 father.html 文件，代码如下： mysites/templates/father.html 文件代码：1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;模板继承&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;p&gt;Django 测试。&lt;/p&gt; &#123;% block mainbody %&#125; &lt;p&gt;original&lt;/p&gt; &#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; 以上代码中，名为 mainbody 的 block 标签是可以被继承者们替换掉的部分。 所有的 block 标签告诉模板引擎，子模板可以重载这些部分。 son.html 中继承 father.html，并替换特定 block，son.html 修改后的代码如下： mysites/templates/son.html 文件代码： 12345&#123;%extends "father.html" %&#125; &#123;% block mainbody %&#125;&lt;p&gt;继承了 base.html 文件&lt;/p&gt;&#123;% endblock %&#125; 第一行代码说明 son.html 继承了 father.html 文件。可以看到，这里相同名字的 block 标签用以替换 father.html 的相应 block。 django模型Django 对各种数据库提供了很好的支持，包括：PostgreSQL、MySQL、SQLite、Oracle。 Django 为这些数据库提供了统一的调用API。 安装mysqlclient直接在pycharm的setting里面导入mysqlclient包,如果提示安装错误可以查看下面的链接：mysqlclient安装出错 数据库配置我们在项目的 settings.py 文件中找到 DATABASES 配置项，将其信息修改为：12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', # 或者使用 mysql.connector.django 'NAME': 'test_db',# 数据库名称 'USER': 'root',# 用户 'PASSWORD': 'an1234',# 密码 'HOST':'localhost',# ip 'PORT':'3306',# 端口 &#125;&#125; 注意：这里添加了中文注释，所以你需要在 HelloWorld/settings.py 文件头部添加 # -- coding: UTF-8 --。 上面包含数据库名称和用户的信息，它们与 MySQL 中对应数据库和用户的设置相同。Django 根据这一设置，与 MySQL 中相应的数据库和用户连接起来。 定义模型 创建 APPDjango规定，如果要使用模型，必须要创建一个app。我们使用以下命令创建一个 TestModel 的 app: 1django-admin startapp TestModel 目录结构如下：1234567Hellodjango|-- TestModel| |-- __init__.py| |-- admin.py| |-- models.py| |-- tests.py| `-- views.py 修改 TestModel/models.py 文件： 1234from django.db import modelsclass Test(models.Model): name = models.CharField(max_length=20) 接下来在settings.py中找到INSTALLED_APPS这一项，如下： 123456789INSTALLED_APPS = ( &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &apos;TestModel&apos;, # 添加此项) 在命令行中运行： 12345$ python manage.py migrate # 创建表结构$ python manage.py makemigrations TestModel # 让 Django 知道我们在我们的模型有一些变更$ python manage.py migrate TestModel # 创建表结构 看到几行 “Creating table…” 的字样，你的数据表就创建好了。1234Creating tables ...……Creating table TestModel_test #我们自定义的表…… 表名组成结构为：应用名_类名（如：TestModel_test）。 注意：尽管我们没有在models给表设置主键，但是Django会自动添加一个id作为主键。 接下来你就可以对数据库进行操作了 相关链接 python3 django配置数据库（mysql） Django中数据库配置 Django 配置MySQL数据库 [Django] Django(五) 配置mysql数据库 django-数据库【配置】]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python巩固]]></title>
    <url>%2F2019%2F03%2F30%2Fpython%E5%B7%A9%E5%9B%BA%2F</url>
    <content type="text"><![CDATA[巩固python基础 中文编码Python中默认的编码格式是 ASCII 格式，在没修改编码格式时无法正确打印汉字，所以在读取中文时会报错。解决方法为只要在文件开头加入 # -*- coding: UTF-8 -*- 或者 #coding=utf-8 就行了 注意：**#coding=utf-8 的 =** 号两边不要空格。 标识符 以下划线开头的标识符是有特殊意义的。以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入。 以双下划线开头的 __foo 代表类的私有成员，以双下划线开头和结尾的 foo 代表 Python 里特殊方法专用的标识，如 init() 代表类的构造函数。 行和缩进学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。 多行语句Python语句中一般以新行作为语句的结束符。 但是我们可以使用斜杠（ \）将一行的语句分为多行显示，如下所示：123total = item_one + \ item_two + \ item_three 语句中包含 [], {} 或 () 括号就不需要使用多行连接符。 Print 输出print 默认输出是换行的，如果要实现不换行需要在变量末尾加上逗号 , 12345678910111213# -*- coding: UTF-8 -*-x="a"y="b"# 换行输出print xprint yprint '---------'# 不换行输出print x,print y,# 不换行输出print x,y 以上实例执行结果为： a ba b a b 标准数据类型Python有五个标准的数据类型： Numbers（数字） String（字符串） List（列表） Tuple（元组） Dictionary（字典） 数字 长整型也可以使用小写 l，但是还是建议您使用大写 L，避免与数字 1 混淆。Python使用 L 来显示长整型。 Python 还支持复数，复数由实数部分和虚数部分构成，可以用 a + bj,或者 complex(a,b) 表示， 复数的实部 a 和虚部 b 都是浮点型。注意：long 类型只存在于 Python2.X 版本中，在 2.2 以后的版本中，int 类型数据溢出后会自动转为long类型。在 Python3.X 版本中 long 类型被移除，使用 int 替代。 字符串python的字串列表有2种取值顺序: 从左到右索引默认0开始的，最大范围是字符串长度少1 从右到左索引默认-1开始的，最大范围是字符串开头实例12345678910# -*- coding: UTF-8 -*- str = 'Hello World!' print str # 输出完整字符串print str[0] # 输出字符串中的第一个字符print str[2:5] # 输出字符串中第三个至第五个之间的字符串print str[2:] # 输出从第三个字符开始的字符串print str * 2 # 输出字符串两次print str + "TEST" # 输出连接的字符串 以上实例输出结果： Hello World!Hllollo World!Hello World!Hello World!Hello World!TEST Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串： 列表List（列表） 是 Python 中使用最频繁的数据类型。列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。列表用 [ ] 标识，是 python 最通用的复合数据类型。 列表方法 序号 方法 1 list.append(obj) 在列表末尾添加新的对象 2 list.count(obj) 统计某个元素在列表中出现的次数 3 list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） 4 list.index(obj) 从列表中找出某个值第一个匹配项的索引位置 5 list.insert(index, obj) 将对象插入列表 6 list.pop([index=-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 7 list.remove(obj) 移除列表中某个值的第一个匹配项 8 list.reverse() 反向列表中元素 9 list.sort(cmp=None, key=None, reverse=False) 对原列表进行排序 实例1234567# -*- coding: UTF-8 -*- # 列表vowels = ['e', 'a', 'u', 'o', 'i']# 降序vowels.sort(reverse=True)# 输出结果print '降序输出:', vowel 以上实例输出结果如下： 降序输出: [‘u’, ‘o’, ‘i’, ‘e’, ‘a’] 元组元组是另一个数据类型，类似于 List（列表）。元组用 , 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。 创建空元组 tup1 = () 元组中只包含一个元素时，需要在元素后面添加逗号 tup1 = (50,) 实例1234567891011# -*- coding: UTF-8 -*-tuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )tinytuple = (123, 'john') print tuple # 输出完整元组print tuple[0] # 输出元组的第一个元素print tuple[1:3] # 输出第二个至第三个的元素 print tuple[2:] # 输出从第三个开始至列表末尾的所有元素print tinytuple * 2 # 输出元组两次print tuple + tinytuple # 打印组合的元组 以上实例输出结果： (‘runoob’, 786, 2.23, ‘john’, 70.2)runoob(786, 2.23)(2.23, ‘john’, 70.2)(123, ‘john’, 123, ‘john’)(‘runoob’, 786, 2.23, ‘john’, 70.2, 123, ‘john’) 字典字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。字典用”{ }”标识。字典由索引(key)和它对应的值value组成。 删除字典元素####### 实例123456# -*- coding: UTF-8 -*-dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125; del dict['Name'] # 删除键是'Name'的条目dict.clear() # 清空词典所有条目del dict # 删除词典 内置方法： 序号 函数及描述 1 dict.clear() 删除字典内所有元素 2 dict.copy() 返回一个字典的浅复制 3 dict.fromkeys(seq[, val]) 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值 4 dict.get(key, default=None) 返回指定键的值，如果值不在字典中返回default值 5 dict.has_key(key) 如果键在字典dict里返回true，否则返回false 6 dict.items() 以列表返回可遍历的(键, 值) 元组数组 7 dict.keys() 以列表返回一个字典所有的键 8 dict.setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default 9 dict.update(dict2) 把字典dict2的键/值对更新添加到dict里 10 dict.values() 以列表返回字典中的所有值 11 pop(key[,default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 12 popitem() 随机返回并删除字典中的一对键和值。 ####### 实例以下实例展示了 fromkeys()函数的使用方法： 123456789# -*- coding: UTF-8 -*- seq = ('Google', 'Runoob', 'Taobao') dict = dict.fromkeys(seq)print "新字典为 : %s" % str(dict) dict = dict.fromkeys(seq, 10)print "新字典为 : %s" % str(dict) 以上实例输出结果为： 新字典为 : {‘Google’: None, ‘Taobao’: None, ‘Runoob’: None}新字典为 : {‘Google’: 10, ‘Taobao’: 10, ‘Runoob’: 10} 实例123456789101112# -*- coding: UTF-8 -*- dict = &#123;&#125;dict['one'] = "This is one"dict[2] = "This is two"tinydict = &#123;'name': 'john','code':6734, 'dept': 'sales'&#125; print dict['one'] # 输出键为'one' 的值print dict[2] # 输出键为 2 的值print tinydict # 输出完整的字典print tinydict.keys() # 输出所有键print tinydict.values() # 输出所有值 输出结果为： This is oneThis is two{‘dept’: ‘sales’, ‘code’: 6734, ‘name’: ‘john’}[‘dept’, ‘code’, ‘name’][‘sales’, 6734, ‘john’] 运算符算数运算符 ** 幂 - 返回x的y次幂 a**b 为10的20次方， 输出结果 100000000000000000000 // 取整除 - 返回商的整数部分（向下取整） &gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5 位运算符 运算符 描述 实例 &amp; 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a &amp; b) 输出结果 12 ，二进制解释： 0000 1100 &#124; 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 (a &#124; b) 输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。 &lt;&lt; 左移动运算符：运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数字指定了移动的位数，高位丢弃，低位补0。 a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000 &gt;&gt; 右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，&gt;&gt; 右边的数字指定了移动的位数 a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111 逻辑运算符Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20: 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 成员运算符除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 身份运算符身份运算符用于比较两个对象的存储单元 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。 is 与 == 区别：is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。 字符串运算符 运算符 描述 r/R 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母”r”（可以大小写）以外，与普通字符串有着几乎完全相同的语法。 &gt;&gt;&gt;print r’\n’ \n &gt;&gt;&gt; print R’\n’ \n 运算符优先级以下表格列出了从最高到最低优先级的所有运算符： 运算符 描述 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，取模和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算符 &amp; 位 ‘AND’ ^ \ &#124; 位运算符 &lt;= &lt; &gt; &gt;= 比较运算符 &lt;&gt; == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not and or 逻辑运算符 语句 python 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现，如果判断需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功。 pass 语句Python pass 是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。 实例：12345678910# -*- coding: UTF-8 -*- # 输出 Python 的每个字母for letter in 'Python': if letter == 'h': pass print '这是 pass 块' print '当前字母 :', letter print "Good bye!" 以上实例执行结果： 当前字母 : P当前字母 : y当前字母 : t这是 pass 块当前字母 : h当前字母 : o当前字母 : nGood bye! 数学函数math 模块、cmath 模块Python 中数学运算常用的函数基本都在 math 模块、cmath 模块中。 Python math 模块提供了许多对浮点数的数学运算函数。 Python cmath 模块包含了一些用于复数运算的函数。 cmath 模块的函数跟 math 模块函数基本一致，区别是 cmath 模块运算的是复数，math 模块运算的是数学运算。 查看 math 查看包中的内容:1234&gt;&gt;&gt; import math&gt;&gt;&gt; dir(math)['__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc']&gt;&gt;&gt; 查看 cmath 查看包中的内容1234&gt;&gt;&gt; import cmath&gt;&gt;&gt; dir(cmath)['__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'cos', 'cosh', 'e', 'exp', 'inf', 'infj', 'isclose', 'isfinite', 'isinf', 'isnan', 'log', 'log10', 'nan', 'nanj', 'phase', 'pi', 'polar', 'rect', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau']&gt;&gt;&gt; Python数学函数 函数 返回值 ( 描述 ) abs(x) 返回数字的绝对值，如abs(-10) 返回 10 ceil(x) 返回数字的上入整数，如math.ceil(4.1) 返回 5 cmp(x, y) 如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1 exp(x) 返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045 fabs(x) 返回数字的绝对值，如math.fabs(-10) 返回10.0 floor(x) 返回数字的下舍整数，如math.floor(4.9)返回 4 log(x) 如math.log(math.e)返回1.0,math.log(100,10)返回2.0 log10(x) 返回以10为基数的x的对数，如math.log10(100)返回 2.0 max(x1, x2,…) 返回给定参数的最大值，参数可以为序列。 min(x1, x2,…) 返回给定参数的最小值，参数可以为序列。 modf(x) 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。 pow(x, y) x**y 运算后的值。 round(x [,n]) 返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。 sqrt(x) 返回数字x的平方根 Python随机数函数随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。 Python包含以下常用随机数函数： 函数 描述 choice(seq) 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。 randrange ([start,] stop [,step]) 从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1 random() 随机生成下一个实数，它在[0,1)范围内。 seed([x]) 改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。 shuffle(lst) 将序列的所有元素随机排序 uniform(x, y) 随机生成下一个实数，它在[x,y]范围内。 Python三角函数Python包括以下三角函数： 函数 描述 acos(x) 返回x的反余弦弧度值。 asin(x) 返回x的反正弦弧度值。 atan(x) 返回x的反正切弧度值。 atan2(y, x) 返回给定的 X 及 Y 坐标值的反正切值。 cos(x) 返回x的弧度的余弦值。 hypot(x, y) 返回欧几里德范数 sqrt(xx + yy)。 sin(x) 返回的x弧度的正弦值。 tan(x) 返回x弧度的正切值。 degrees(x) 将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0 radians(x) 将角度转换为弧度 Python数学常量 常量 描述 pi 数学常量 pi（圆周率，一般以π来表示） e 数学常量 e，e即自然常数（自然常数）。 时间time时间间隔是以秒为单位的浮点小数。 每个时间戳都以自从1970年1月1日午夜（历元）经过了多长时间来表示。 Python 的 time 模块下有很多函数可以转换常见日期格式。如函数time.time()用于获取当前时间戳, Time 模块Time 模块包含了以下内置函数，既有时间处理的，也有转换时间格式的： 序号 函数及描述 1 time.altzone 返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。 2 time.asctime([tupletime]) 接受时间元组并返回一个可读的形式为”Tue Dec 11 18:07:14 2008”（2008年12月11日 周二18时07分14秒）的24个字符的字符串。 3 time.clock( ) 用以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。 4 time.ctime([secs]) 作用相当于asctime(localtime(secs))，未给参数相当于asctime() 5 time.gmtime([secs]) 接收时间戳（1970纪元后经过的浮点秒数）并返回格林威治天文时间下的时间元组t。注：t.tm_isdst始终为0 6 time.localtime([secs]) 接收时间戳（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组t（t.tm_isdst可取0或1，取决于当地当时是不是夏令时）。 7 time.mktime(tupletime) 接受时间元组并返回时间戳（1970纪元后经过的浮点秒数）。 8 time.sleep(secs) 推迟调用线程的运行，secs指秒数。 9 time.strftime(fmt[,tupletime]) 接收以时间元组，并返回以可读字符串表示的当地时间，格式由fmt决定。 10 time.strptime(str,fmt=’%a %b %d %H:%M:%S %Y’) 根据fmt的格式把一个时间字符串解析为时间元组。 11 time.time( ) 返回当前时间的时间戳（1970纪元后经过的浮点秒数）。 12 time.tzset() 根据环境变量TZ重新初始化时间相关设置。 实例以下实例展示了 time() 函数的使用方法：123456#!/usr/bin/pythonimport timeprint "time.time(): %f " % time.time()print time.localtime( time.time() )print time.asctime( time.localtime(time.time()) ) 运行结果： 1553931680.6086578time.struct_time(tm_year=2019, tm_mon=3, tm_mday=30, tm_hour=15, tm_min=41, tm_sec=57, tm_wday=5, tm_yday=89, tm_isdst=0)Sat Mar 30 15:43:23 2019 日历（Calendar）模块此模块的函数都是日历相关的，例如打印某月的字符月历。 星期一是默认的每周第一天，星期天是默认的最后一天。更改设置需调用calendar.setfirstweekday()函数。模块包含了以下内置函数： 序号 函数及描述 1 calendar.calendar(year,w=2,l=1,c=6) 返回一个多行字符串格式的year年年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为21 W+18+2 C。l是每星期行数。 2 calendar.firstweekday( ) 返回当前每周起始日期的设置。默认情况下，首次载入caendar模块时返回0，即星期一。 3 calendar.isleap(year) 是闰年返回 True，否则为 False。` 4 calendar.leapdays(y1,y2) 返回在Y1，Y2两年之间的闰年总数。 5 calendar.month(year,month,w=2,l=1) 返回一个多行字符串格式的year年month月日历，两行标题，一周一行。每日宽度间隔为w字符。每行的长度为7* w+6。l是每星期的行数。 6 calendar.monthcalendar(year,month) 返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数。Year年month月外的日期都设为0;范围内的日子都由该月第几日表示，从1开始。 7 calendar.monthrange(year,month) 返回两个整数。第一个是该月的星期几的日期码，第二个是该月的日期码。日从0（星期一）到6（星期日）;月从1到12。 8 calendar.prcal(year,w=2,l=1,c=6) 相当于 print calendar.calendar(year,w,l,c). 9 calendar.prmonth(year,month,w=2,l=1) 相当于 print calendar.calendar（year，w，l，c）。 10 calendar.setfirstweekday(weekday) 设置每周的起始日期码。0（星期一）到6（星期日）。 11 calendar.timegm(tupletime) 和time.gmtime相反：接受一个时间元组形式，返回该时刻的时间戳（1970纪元后经过的浮点秒数）。 12 calendar.weekday(year,month,day) 返回给定日期的日期码。0（星期一）到6（星期日）。月份为 1（一月） 到 12（12月）。 实例获取某月日历Calendar模块有很广泛的方法用来处理年历和月历，例如打印某月的月历： 1234567# -*- coding: UTF-8 -*- import calendar cal = calendar.month(2019, 3)print "以下输出2019年3月份的日历:"print cal 运行结果： March 2019 Mo Tu We Th Fr Sa Su 1 2 3 4 5 6 7 8 9 1011 12 13 14 15 16 1718 19 20 21 22 23 2425 26 27 28 29 30 31 函数定义一个函数你可以定义一个由自己想要功能的函数，以下是简单的规则： 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()。 任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。 函数内容以冒号起始，并且缩进。 return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。 可更改(mutable)与不可更改(immutable)对象在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。 python 函数的参数传递： 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响 实例1234567# -*- coding: UTF-8 -*-def ChangeInt( a ): a = 10 b = 2ChangeInt(b)print b # 结果是 2 参数以下是调用函数时可使用的正式参数类型： 必备参数 关键字参数 默认参数 不定长参数 不定长参数你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，声明时不会命名。基本语法如下：1234def functionname([formal_args,] *var_args_tuple ): "函数_文档字符串" function_suite return [expression] 加了星号（*）的变量名会存放所有未命名的变量参数。不定长参数实例如下： ####### 实例1234567891011121314# -*- coding: UTF-8 -*- # 可写函数说明def printinfo( arg1, *vartuple ): "打印任何传入的参数" print "输出: " print arg1 for var in vartuple: print var return; # 调用printinfo 函数printinfo( 10 );printinfo( 70, 60, 50 ); 以上实例输出结果： 输出:10输出:706050 匿名函数python 使用 lambda 来创建匿名函数。 lambda只是一个表达式，函数体比def简单很多。 lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。 lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。 虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。语法lambda函数的语法只包含一个语句，如下： lambda [arg1 [,arg2,…..argn]]:expression 实例12345678# -*- coding: UTF-8 -*- # 可写函数说明sum = lambda arg1, arg2: arg1 + arg2; # 调用sum函数print "相加后的值为 : ", sum( 10, 20 )print "相加后的值为 : ", sum( 20, 20 ) 以上实例输出结果： 相加后的值为 : 30相加后的值为 : 40 Python中的包包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。 简单来说，包就是文件夹，但该文件夹下必须存在 init.py 文件, 该文件的内容可以为空。init.py 用于标识当前文件夹是一个包。例如：考虑一个在 package_runoob 目录下的 runoob1.py、runoob2.py、init.py 文件，test.py 为测试调用包的代码，目录结构如下：12345678910111213test.pypackage_runoob|-- __init__.py|-- runoob1.py|-- runoob2.py 源代码如下：package_runoob/runoob1.py​```python# -*- coding: UTF-8 -*-def runoob1(): print "I'm in runoob1" package_runoob/runoob2.py 1234# -*- coding: UTF-8 -*-def runoob2(): print "I'm in runoob2" 现在，在 package_runoob 目录下创建 init.py： package_runoob/init.py1234567# -*- coding: UTF-8 -*-if __name__ == '__main__': print '作为主程序运行'else: print 'package_runoob 初始化' 然后我们在 package_runoob 同级目录下创建 test.py 来调用 package_runoob 包 test.py12345678# -*- coding: UTF-8 -*-# 导入 Phone 包from package_runoob.runoob1 import runoob1from package_runoob.runoob2 import runoob2runoob1()runoob2() 以上实例输出结果： package_runoob 初始化I’m in runoob1I’m in runoob2 文件读取键盘输入Python提供了两个内置函数从标准输入读入一行文本，默认的标准输入是键盘。如下： raw_input inputraw_input函数raw_input([prompt]) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）： ####### 实例1234# -*- coding: UTF-8 -*- str = raw_input("请输入：")print "你输入的内容是: ", str 这会产生如下的对应着输入的结果： 请输入：Hello Python！你输入的内容是: Hello Python！ input函数input([prompt]) 函数和 raw_input([prompt]) 函数基本类似，但是 input 可以接收一个Python表达式作为输入，并将运算结果返回。 ####### 实例1234# -*- coding: UTF-8 -*- str = input("请输入：")print "你输入的内容是: ", str 这会产生如下的对应着输入的结果： 请输入：[x*5 for x in range(2,10,2)]你输入的内容是: [10, 20, 30, 40] 打开和关闭文件Python 提供了必要的函数和方法进行默认情况下的文件基本操作。你可以用 file 对象做大部分的文件操作。 open 函数你必须先用Python内置的open()函数打开一个文件，创建一个file对象，相关的方法才可以调用它进行读写。 语法： 1file object = open(file_name [, access_mode][, buffering]) 各个参数的细节如下： file_name：file_name变量是一个包含了你要访问的文件名称的字符串值。 access_mode：access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。 buffering:如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。 注意：使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法。 open() 函数常用形式是接收两个参数：文件名(file)和模式(mode)。 1open(file, mode=&apos;r&apos;) 完整的语法格式为： 1open(file, mode=&apos;r&apos;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) 参数说明: file: 必需，文件路径（相对或者绝对路径）。 mode: 可选，文件打开模式 buffering: 设置缓冲 encoding: 一般使用utf8 errors: 报错级别 newline: 区分换行符 closefd: 传入的file参数类型 opener: 不同模式打开文件的完全列表： 模式 描述 t 文本模式 (默认)。 x 写模式，新建一个文件，如果该文件已存在则会报错。 b 二进制模式。 + 打开一个文件进行更新(可读可写)。 U 通用换行模式（不推荐）。 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 File对象的属性一个文件被打开后，你有一个file对象，你可以得到有关该文件的各种信息。 以下是和file对象相关的所有属性的列表： 属性 描述 file.closed 返回true如果文件已被关闭，否则返回false。 file.mode 返回被打开文件的访问模式。 file.name 返回文件的名称。 file.softspace 如果用print输出后，必须跟一个空格符，则返回false。否则返回true。 如下实例： 12345678# -*- coding: UTF-8 -*- # 打开一个文件fo = open("foo.txt", "w")print "文件名: ", fo.nameprint "是否已关闭 : ", fo.closedprint "访问模式 : ", fo.modeprint "末尾是否强制加空格 : ", fo.softspace 以上实例输出结果： 1234文件名: foo.txt是否已关闭 : False访问模式 : w末尾是否强制加空格 : 0 write()方法write()方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。 write()方法不会在字符串的结尾添加换行符(‘\n’)： read()方法read（）方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。语法： fileObject.read([count]) 在这里，被传递的参数是要从已打开文件中读取的字节计数。该方法从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾。 文件定位 tell()方法告诉你文件内的当前位置, 换句话说，下一次的读写会发生在文件开头这么多字节之后。 seek（offset [,from]）方法改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。如果from被设为0，这意味着将文件的开头作为移动字节的参考位置。如果设为1，则使用当前的位置作为参考位置。如果它被设为2，那么该文件的末尾将作为参考位置。 重命名和删除文件Python的os模块提供了帮你执行文件处理操作的方法，比如重命名和删除文件。 要使用这个模块，你必须先导入它，然后才可以调用相关的各种功能。 ####### rename()方法： rename()方法需要两个参数，当前的文件名和新文件名。 语法： os.rename(current_file_name, new_file_name) ######## 实例下例将重命名一个已经存在的文件test1.txt。123456# -*- coding: UTF-8 -*-import os # 重命名文件test1.txt到test2.txt。os.rename( "test1.txt", "test2.txt" ) ####### remove()方法你可以用remove()方法删除文件，需要提供要删除的文件名作为参数。 语法： os.remove(file_name) ######## 实例下例将删除一个已经存在的文件test2.txt。12345# -*- coding: UTF-8 -*-import os# 删除一个已经存在的文件test2.txtos.remove("test2.txt") Python里的目录：所有文件都包含在各个不同的目录下，不过Python也能轻松处理。os模块有许多方法能帮你创建，删除和更改目录。目录方法 mkdir()方法可以使用os模块的mkdir()方法在当前目录下创建新的目录们。你需要提供一个包含了要创建的目录名称的参数。 语法： os.mkdir(“newdir”)例子： chdir()方法可以用chdir()方法来改变当前的目录。chdir()方法需要的一个参数是你想设成当前目录的目录名称。 语法： os.chdir(“newdir”) getcwd()方法：getcwd()方法显示当前的工作目录。 语法： os.getcwd() rmdir()方法rmdir()方法删除目录，目录名称以参数传递。 在删除这个目录之前，它的所有内容应该先被清除。 语法： os.rmdir(‘dirname’) 异常处理异常处理 try/except语句。try/except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。 如果你不想在异常发生时结束你的程序，只需在try里捕获它。 语法： 12345678try:&lt;语句&gt; #运行别的代码except &lt;名字&gt;：&lt;语句&gt; #如果在try部份引发了&apos;name&apos;异常except &lt;名字&gt;，&lt;数据&gt;:&lt;语句&gt; #如果引发了&apos;name&apos;异常，获得附加的数据else:&lt;语句&gt; #如果没有异常发生 try-finally 语句try-finally 语句无论是否发生异常都将执行最后的代码。语法 12345try:&lt;语句&gt;finally:&lt;语句&gt; #退出try时总会执行raise 实例以下为单个异常的实例： 12345678910# -*- coding: UTF-8 -*-# 定义函数def temp_convert(var): try: return int(var) except ValueError, Argument: print "参数没有包含数字\n", Argument# 调用函数temp_convert("xyz"); 以上程序执行结果如下： 123$ python test.py 参数没有包含数字invalid literal for int() with base 10: &apos;xyz&apos; 触发异常我们可以使用raise语句自己触发异常 raise语法格式如下： 1raise [Exception [, args [, traceback]]] 语句中 Exception 是异常的类型（例如，NameError）参数标准异常中任一种，args 是自已提供的异常参数。 最后一个参数是可选的（在实践中很少使用），如果存在，是跟踪异常对象。 实例一个异常可以是一个字符串，类或对象。 1234def functionName( level ): if level &lt; 1: raise Exception("Invalid level!", level) # 触发异常后，后面的代码就不会再执行 面向对象 getattr(obj, name[, default]) : 访问对象的属性。 hasattr(obj,name) : 检查是否存在一个属性。 setattr(obj,name,value) : 设置一个属性。如果属性不存在，会创建一个新属性。 delattr(obj, name) : 删除属性。 issubclass() - 布尔函数判断一个类是另一个类的子类或者子孙类，语法：issubclass(sub,sup) isinstance(obj, Class) 布尔函数如果obj是Class类的实例对象或者是一个Class子类的实例对象则返回true。 基础重载方法 序号 方法, 描述 &amp; 简单的调用 1 init ( self [,args…] ) 构造函数 简单的调用方法: obj = className(args) 2 del( self ) 析构方法, 删除一个对象 简单的调用方法 : del obj 3 repr( self ) 转化为供解释器读取的形式 简单的调用方法 : repr(obj) 4 str( self ) 用于将值转化为适于人阅读的形式 简单的调用方法 : str(obj) 5 cmp ( self, x ) 对象比较 简单的调用方法 : cmp(obj, x)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Choice]]></title>
    <url>%2F2019%2F03%2F29%2F%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[在学习java半途中投入python的怀抱 i take a long long time to think about what should i choose python or java so that my head get a headache.finally, i chose python. i still remember those days when i began to study python,it was my spiritual cereal,yes, i think it was! i thought it was a cool language so that i spent little time in thinking some mad but seem no matter thing,actually it “fuck them”. in the begining ,i was blind because many of my partners in laborattory chose java.i think maybe i could fall in love with it,i just need time,but unfortunately i feel unsafe and wandering in the process of learn java,on the contrary , i feel good if i choose python.for that decision ,i ask for some suggestion from the former member,i talk with thise parter, i sell my book in order to make sure my inner decision. i really really really decided, No matter where i can arrive ,i will try my best. 微笑着 旋转着 紧握着双手 整个世界旋转成模糊一片 你却屹立不移酩酊大醉 浑身湿透 脱掉胶鞋 裸足奔跑 破壳而出风中传来你 头发的味道 我深吸口气踏着水潭 浑身湿透 脱掉胶鞋即使满是鲜血 我仍昂然奋起]]></content>
      <categories>
        <category>感想</category>
      </categories>
      <tags>
        <tag>-日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习java]]></title>
    <url>%2F2019%2F03%2F27%2F%E5%AD%A6%E4%B9%A0java%2F</url>
    <content type="text"><![CDATA[java学习过程中的注意事项及与其他语言不同的地方 java开发环境的配置微信公众号：软件安装管家 学习笔记Hello Java第一个 JAVA 程序12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("Hello World"); &#125;&#125; 基本语法编写Java程序时，应注意以下几点：· 大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。 · 类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。 · 方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。 · 源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。 · 主方法入口：所有的Java 程序由public static void main(String []args)方法开始执行。 Java枚举Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的bug。1234567891011class FreshJuice &#123; enum FreshJuiceSize&#123; SMALL, MEDIUM , LARGE &#125; FreshJuiceSize size;&#125; public class FreshJuiceTest &#123; public static void main(String []args)&#123; FreshJuice juice = new FreshJuice(); juice.size = FreshJuice.FreshJuiceSize.MEDIUM ; &#125;&#125; 内置数据类型Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。byte： byte 数据类型是8位、有符号的，以二进制补码表示的整数； 最小值是 -128（-2^7）； 最大值是 127（2^7-1）； 默认值是 0； byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一； 例子：byte a = 100，byte b = -50。 short： short 数据类型是 16 位、有符号的以二进制补码表示的整数 最小值是 -32768（-2^15）； 最大值是 32767（2^15 - 1）； Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一； 默认值是 0； 例子：short s = 1000，short r = -20000。 int： int 数据类型是32位、有符号的以二进制补码表示的整数； 最小值是 -2,147,483,648（-2^31）； 最大值是 2,147,483,647（2^31 - 1）； 一般地整型变量默认为 int 类型； 默认值是 0 ； 例子：int a = 100000, int b = -200000。 long： long 数据类型是 64 位、有符号的以二进制补码表示的整数； 最小值是 -9,223,372,036,854,775,808（-2^63）； 最大值是 9,223,372,036,854,775,807（2^63 -1）； 这种类型主要使用在需要比较大整数的系统上； 默认值是 0L； 例子： long a = 100000L，Long b = -200000L。“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。 float： float 数据类型是单精度、32位、符合IEEE 754标准的浮点数； float 在储存大型浮点数组的时候可节省内存空间； 默认值是 0.0f； 浮点数不能用来表示精确的值，如货币； 例子：float f1 = 234.5f。 double： double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数； 浮点数的默认类型为double类型； double类型同样不能表示精确的值，如货币； 默认值是 0.0d； 例子：double d1 = 123.4。 boolean： boolean数据类型表示一位的信息； 只有两个取值：true 和 false； 这种类型只作为一种标志来记录 true/false 情况； 默认值是 false； 例子：boolean one = true。 char： char类型是一个单一的 16 位 Unicode 字符； 最小值是 \u0000 （即为0）； 最大值是 \uffff （即为65,535）； char 数据类型可以储存任何字符； 例子：char letter = ‘A’;。 实例123456789101112131415161718192021public class PrimitiveTypeTest &#123; public static void main(String[] args) &#123; // byte System.out.println("基本类型：byte 二进制位数：" + Byte.SIZE); System.out.println("包装类：java.lang.Byte"); System.out.println("最小值：Byte.MIN_VALUE=" + Byte.MIN_VALUE); System.out.println("最大值：Byte.MAX_VALUE=" + Byte.MAX_VALUE); System.out.println(); //其他类型略 // char System.out.println("基本类型：char 二进制位数：" + Character.SIZE); System.out.println("包装类：java.lang.Character"); // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台 System.out.println("最小值：Character.MIN_VALUE=" + (int) Character.MIN_VALUE); // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台 System.out.println("最大值：Character.MAX_VALUE=" + (int) Character.MAX_VALUE); &#125; &#125; 自动类型转换整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。 转换从低级到高级。 低 ————————————&gt; 高byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double 必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。 实例public class ZiDongLeiZhuan{ public static void main(String[] args){ char c1=&apos;a&apos;;//定义一个char类型 int i1 = c1;//char自动类型转换为int System.out.println(&quot;char自动类型转换为int后的值等于&quot;+i1); char c2 = &apos;A&apos;;//定义一个char类型 int i2 = c2+1;//char 类型和 int 类型计算 System.out.println(&quot;char类型和int计算后的值等于&quot;+i2); } } 运行结果为:char自动类型转换为int后的值等于97char类型和int计算后的值等于66解析：c1 的值为字符 a ,查 ASCII 码表可知对应的 int 类型值为 97， A 对应值为 65，所以 i2=65+1=66。 Java 变量类型Java语言支持的变量类型有： 类变量：独立于方法之外的变量，用 static 修饰。 实例变量：独立于方法之外的变量，不过没有 static 修饰。 局部变量：类的方法中的变量。局部变量 局部变量声明在方法、构造方法或者语句块中； 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁； 访问修饰符不能用于局部变量； 局部变量只在声明它的方法、构造方法或者语句块中可见； 局部变量是在栈上分配的。 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 实例变量 实例变量声明在一个类中，但在方法、构造方法和语句块之外； 当一个对象被实例化之后，每个实例变量的值就跟着确定； 实例变量在对象创建的时候创建，在对象被销毁的时候销毁； 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息； 实例变量可以声明在使用前或者使用后； 访问修饰符可以修饰实例变量； 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见； 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定； 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。类变量（静态变量） 类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。 静态变量在第一次被访问时创建，在程序结束时销毁。 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。 静态变量可以通过：ClassName.VariableName的方式访问。 类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。 非访问修饰符为了实现一些其他的功能，Java 也提供了许多非访问修饰符。 static 修饰符，用来修饰类方法和类变量。 final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 abstract 修饰符，用来创建抽象类和抽象方法。 synchronized 和 volatile 修饰符，主要用于线程的编程。 static 修饰符 静态变量： static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。 静态方法： static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。 对类变量和方法的访问可以直接使用 classname.variablename 和 classname.methodname 的方式访问。 final 修饰符final 变量： final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。 final 修饰符通常和 static 修饰符一起使用来创建类常量。 final 方法 类中的 final 方法可以被子类继承，但是不能被子类修改。 声明 final 方法的主要目的是防止该方法的内容被修改。 final 类 final 类不能被继承，没有类能够继承 final 类的任何特性。 abstract 修饰符抽象类： 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。 一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。 抽象类可以包含抽象方法和非抽象方法。 抽象方法 抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。 抽象方法不能被声明成 final 和 static。 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 抽象方法的声明以分号结尾，例如：public abstract sample();。 位运算符Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。 位运算符作用在所有的位上，并且按位运算。假设a = 60，b = 13;它们的二进制格式表示将如下： 1234567A = 0011 1100B = 0000 1101-----------------A&amp;b = 0000 1100A | B = 0011 1101A ^ B = 0011 0001~A= 1100 0011 下表列出了位运算符的基本运算,假设整数变量A的值为60和变量B的值为13： 操作符 描述 例子 ＆ 如果相对应位都是1，则结果为1，否则为0 （A＆B），得到12，即0000 1100 &#124; 如果相对应位都是0，则结果为0，否则为1 （A &#124;B）得到61，即 0011 1101 ^ 如果相对应位值相同，则结果为0，否则为1 （A ^ B）得到49，即 0011 0001 〜 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。 （〜A）得到-61，即1100 0011 &lt;&lt; 按位左移运算符。左操作数按位左移右操作数指定的位数。 A &lt;&lt; 2得到240，即 1111 0000 &gt;&gt; 按位右移运算符。左操作数按位右移右操作数指定的位数。 A &gt;&gt; 2得到15即 1111 &gt;&gt;&gt; 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 A&gt;&gt;&gt;2得到15即0000 1111 实例123456789101112131415161718192021222324252627public class Test &#123; public static void main(String[] args) &#123; int a = 60; /* 60 = 0011 1100 */ int b = 13; /* 13 = 0000 1101 */ int c = 0; c = a &amp; b; /* 12 = 0000 1100 */ System.out.println("a &amp; b = " + c ); c = a | b; /* 61 = 0011 1101 */ System.out.println("a | b = " + c ); c = a ^ b; /* 49 = 0011 0001 */ System.out.println("a ^ b = " + c ); c = ~a; /*-61 = 1100 0011 */ System.out.println("~a = " + c ); c = a &lt;&lt; 2; /* 240 = 1111 0000 */ System.out.println("a &lt;&lt; 2 = " + c ); c = a &gt;&gt; 2; /* 15 = 1111 */ System.out.println("a &gt;&gt; 2 = " + c ); c = a &gt;&gt;&gt; 2; /* 15 = 0000 1111 */ System.out.println("a &gt;&gt;&gt; 2 = " + c ); &#125;&#125; 以上实例编译运行结果如下： 1234567a &amp; b = 12a | b = 61a ^ b = 49~a = -61a &lt;&lt; 2 = 240a &gt;&gt; 2 = 15a &gt;&gt;&gt; 2 = 15 instanceof 运算符该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。 instanceof运算符使用格式如下： 1( Object reference variable ) instanceof (class/interface type) 如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。 下面是一个例子： 12String name = &quot;James&quot;;boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真 如果被比较的对象兼容于右侧类型,该运算符仍然返回true。 Java运算符优先级下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。 类别 操作符 关联性 后缀 () [] . (点操作符) 左到右 一元 + + - ！〜 从右到左 乘性 * /％ 左到右 加性 + - 左到右 移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 左到右 关系 &gt;&gt; = &lt;&lt; = 左到右 相等 == != 左到右 按位与 ＆ 左到右 按位异或 ^ 左到右 按位或 &#124; 左到右 逻辑与 &amp;&amp; 左到右 逻辑或 &#124; &#124; 左到右 条件 ？： 从右到左 赋值 = + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = &amp;#124 = 从右到左 逗号 ， 左到右 ava 增强 for 循环Java5 引入了一种主要用于数组的增强型 for 循环。 Java 增强 for 循环语法格式如下: for(声明语句 : 表达式) { //代码句子 } 声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。 表达式：表达式是要访问的数组名，或者是返回值为数组的方法。 实例12345678910111213141516public class Test &#123; public static void main(String args[])&#123; int [] numbers = &#123;10, 20, 30, 40, 50&#125;; for(int x : numbers )&#123; System.out.print( x ); System.out.print(","); &#125; System.out.print("\n"); String [] names =&#123;"James", "Larry", "Tom", "Lacy"&#125;; for( String name : names ) &#123; System.out.print( name ); System.out.print(","); &#125; &#125;&#125; 以上实例编译运行结果如下： 1210,20,30,40,50,James,Larry,Tom,Lacy, Java switch case 语句语法switch case 语句语法格式如下：1234567891011switch(expression)&#123; case value : //语句 break; //可选 case value : //语句 break; //可选 //你可以有任意数量的case语句 default : //可选 //语句&#125; 注意 如果 case 语句块中没有 break 语句时，JVM 并不会顺序输出每一个 case 对应的返回值，而是继续匹配，匹配不成功则返回默认 case。 如果 case 语句块中没有 break 语句时，匹配成功后，从当前 case 开始，后续所有 case 的值都会输出。 如果当前匹配成功的 case 语句块没有 break 语句，则从当前 case 开始，后续所有 case 的值都会输出，如果后续的 case 语句块有 break 语句则会跳出判断。 Java Number 类 Java 语言为每一个内置数据类型提供了对应的包装类。所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。 这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。 实例：12345678public class Test&#123; public static void main(String args[])&#123; Integer x = 5; x = x + 10; System.out.println(x); &#125;&#125; 以上实例编译运行结果如下：115 Java Math 类 Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。 实例1234567891011public class Test &#123; public static void main (String []args) &#123; System.out.println("90 度的正弦值：" + Math.sin(Math.PI/2)); System.out.println("0度的余弦值：" + Math.cos(0)); System.out.println("60度的正切值：" + Math.tan(Math.PI/3)); System.out.println("1的反正切值： " + Math.atan(1)); System.out.println("π/2的角度值：" + Math.toDegrees(Math.PI/2)); System.out.println(Math.PI); &#125; &#125; 以上实例编译运行结果如下：12345690 度的正弦值：1.00度的余弦值：1.060度的正切值：1.73205080756887671的反正切值： 0.7853981633974483π/2的角度值：90.03.141592653589793 Number &amp; Math 类方法下面的表中列出的是 Number &amp; Math 类常用的一些方法： 序号 方法与描述 1 xxxValue() 将 Number 对象转换为xxx数据类型的值并返回。 2 compareTo() 将number对象与参数比较。 3 equals() 判断number对象是否与参数相等。 4 valueOf() 返回一个 Number 对象指定的内置数据类型 5 toString() 以字符串形式返回值。 6 parseInt() 将字符串解析为int类型。 7 abs() 返回参数的绝对值。 8 ceil() 返回大于等于( &gt;= )给定参数的的最小整数，类型为双精度浮点型。 9 floor() 返回小于等于（&lt;=）给定参数的最大整数 。 10 rint() 返回与参数最接近的整数。返回类型为double。 11 round() 它表示四舍五入，算法为 Math.floor(x+0.5)，即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5) 的结果为12，Math.round(-11.5) 的结果为-11。 12 min() 返回两个参数中的最小值。 13 max() 返回两个参数中的最大值。 14 exp() 返回自然数底数e的参数次方。 15 log() 返回参数的自然数底数的对数值。 16 pow() 返回第一个参数的第二个参数次方。 17 sqrt() 求参数的算术平方根。 18 sin() 求指定double类型参数的正弦值。 19 cos() 求指定double类型参数的余弦值。 20 tan() 求指定double类型参数的正切值。 21 asin() 求指定double类型参数的反正弦值。 22 acos() 求指定double类型参数的反余弦值。 23 atan() 求指定double类型参数的反正切值。 24 atan2() 将笛卡尔坐标转换为极坐标，并返回极坐标的角度值。 25 toDegrees() 将参数转化为角度。 26 toRadians() 将角度转换为弧度。 27 random() 返回一个随机数。 Java Character 类 Character 类用于对单个字符进行操作。Character 类在对象中包装一个基本类型 char 的值 Character 方法下面是Character类的方法： 序号 方法与描述 1 isLetter() 是否是一个字母 2 isDigit() 是否是一个数字字符 3 isWhitespace() 是否是一个空白字符 4 isUpperCase() 是否是大写字母 5 isLowerCase() 是否是小写字母 6 toUpperCase() 指定字母的大写形式 7 toLowerCase() 指定字母的小写形式 8 toString() 返回字符的字符串形式，字符串的长度仅为1 Java String 类 字符串广泛应用 在Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。注意: String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了（详看笔记部分解析）。如果需要对字符串做很多修改，那么应该选择使用 StringBuffer &amp; StringBuilder 类。 创建格式化字符串 我们知道输出格式化数字可以使用 printf() 和 format() 方法。 String 类使用静态方法 format() 返回一个String 对象而不是 PrintStream 对象。 String 类的静态方法 format() 能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。 实例1234System.out.printf("浮点型变量的值为 " + "%f, 整型变量的值为 " + " %d, 字符串变量的值为 " + "is %s", floatVar, intVar, stringVar); 12345String fs;fs = String.format("浮点型变量的值为 " + "%f, 整型变量的值为 " + " %d, 字符串变量的值为 " + " %s", floatVar, intVar, stringVar); String 方法 下面是 String 类支持的方法 SN(序号) 方法描述 1 char charAt(int index) 返回指定索引处的 char 值。 2 int compareTo(Object o) 把这个字符串和另一个对象比较。 3 int compareTo(String anotherString) 按字典顺序比较两个字符串。 4 int compareToIgnoreCase(String str) 按字典顺序比较两个字符串，不考虑大小写。 5 String concat(String str) 将指定字符串连接到此字符串的结尾。 6 boolean contentEquals(StringBuffer sb) 当且仅当字符串与指定的StringBuffer有相同顺序的字符时候返回真。 7 static String copyValueOf(char[] data) 返回指定数组中表示该字符序列的 String。 8 static String copyValueOf(char[] data, int offset, int count) 返回指定数组中表示该字符序列的 String。 9 boolean endsWith(String suffix) 测试此字符串是否以指定的后缀结束。 10 boolean equals(Object anObject) 将此字符串与指定的对象比较。 11 boolean equalsIgnoreCase(String anotherString) 将此 String 与另一个 String 比较，不考虑大小写。 12 byte[] getBytes() 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 13 byte[] getBytes(String charsetName) 使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 14 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此字符串复制到目标字符数组。 15 int hashCode() 返回此字符串的哈希码。 16 int indexOf(int ch) 返回指定字符在此字符串中第一次出现处的索引。 17 int indexOf(int ch, int fromIndex) 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。 18 int indexOf(String str) 返回指定子字符串在此字符串中第一次出现处的索引。 19 int indexOf(String str, int fromIndex) 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。 20 String intern() 返回字符串对象的规范化表示形式。 21 int lastIndexOf(int ch) 返回指定字符在此字符串中最后一次出现处的索引。 22 int lastIndexOf(int ch, int fromIndex) 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。 23 int lastIndexOf(String str) 返回指定子字符串在此字符串中最右边出现处的索引。 24 int lastIndexOf(String str, int fromIndex) 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。 25 int length() 返回此字符串的长度。 26 boolean matches(String regex) 告知此字符串是否匹配给定的正则表达式。 27 boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) 测试两个字符串区域是否相等。 28 boolean regionMatches(int toffset, String other, int ooffset, int len) 测试两个字符串区域是否相等。 29 String replace(char oldChar, char newChar) 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 30 String replaceAll(String regex, String replacement) 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 31 String replaceFirst(String regex, String replacement) 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 32 String[] split(String regex) 根据给定正则表达式的匹配拆分此字符串。 33 String[] split(String regex, int limit) 根据匹配给定的正则表达式来拆分此字符串。 34 boolean startsWith(String prefix) 测试此字符串是否以指定的前缀开始。 35 boolean startsWith(String prefix, int toffset) 测试此字符串从指定索引开始的子字符串是否以指定前缀开始。 36 CharSequence subSequence(int beginIndex, int endIndex) 返回一个新的字符序列，它是此序列的一个子序列。 37 String substring(int beginIndex) 返回一个新的字符串，它是此字符串的一个子字符串。 38 String substring(int beginIndex, int endIndex) 返回一个新字符串，它是此字符串的一个子字符串。 39 char[] toCharArray() 将此字符串转换为一个新的字符数组。 40 String toLowerCase() 使用默认语言环境的规则将此 String 中的所有字符都转换为小写。 41 String toLowerCase(Locale locale) 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。 42 String toString() 返回此对象本身（它已经是一个字符串！）。 43 String toUpperCase() 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。 44 String toUpperCase(Locale locale) 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。 45 String trim() 返回字符串的副本，忽略前导空白和尾部空白。 46 static String valueOf(primitive data type x) 返回给定data type类型x参数的字符串表示形式。 Java StringBuffer 和 StringBuilder 类 当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。 和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。 实例123456789public class Test&#123; public static void main(String args[])&#123; StringBuffer sBuffer = new StringBuffer("菜鸟教程官网："); sBuffer.append("www"); sBuffer.append(".runoob"); sBuffer.append(".com"); System.out.println(sBuffer); &#125;&#125; StringBuffer 方法以下是 StringBuffer 类支持的主要方法： 序号 方法描述 1 public StringBuffer append(String s) 将指定的字符串追加到此字符序列。 2 public StringBuffer reverse() 将此字符序列用其反转形式取代。 3 public delete(int start, int end) 移除此序列的子字符串中的字符。 4 public insert(int offset, int i) 将 int 参数的字符串表示形式插入此序列中。 5 replace(int start, int end, String str) 使用给定 String 中的字符替换此序列的子字符串中的字符。 下面的列表里的方法和 String 类的方法类似： 序号 方法描述 1 int capacity() 返回当前容量。 2 char charAt(int index) 返回此序列中指定索引处的 char 值。 3 void ensureCapacity(int minimumCapacity) 确保容量至少等于指定的最小值。 4 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此序列复制到目标字符数组 dst。 5 int indexOf(String str) 返回第一次出现的指定子字符串在该字符串中的索引。 6 int indexOf(String str, int fromIndex) 从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。 7 int lastIndexOf(String str) 返回最右边出现的指定子字符串在此字符串中的索引。 8 int lastIndexOf(String str, int fromIndex) 返回 String 对象中子字符串最后出现的位置。 9 int length() 返回长度（字符数）。 10 void setCharAt(int index, char ch) 将给定索引处的字符设置为 ch。 11 void setLength(int newLength) 设置字符序列的长度。 12 CharSequence subSequence(int start, int end) 返回一个新的字符序列，该字符序列是此序列的子序列。 13 String substring(int start) 返回一个新的 String，它包含此字符序列当前所包含的字符子序列。 14 String substring(int start, int end) 返回一个新的 String，它包含此序列当前所包含的字符子序列。 15 String toString() 返回此序列中数据的字符串表示形式。 Java 数组声明数组变量1dataType[] arrayRefVar; // 首选的方法 创建数组1arrayRefVar = new dataType[arraySize]; For-Each 循环 JDK 1.5 引进了一种新的循环类型，被称为 For-Each 循环或者加强型循环，它能在不使用下标的情况下遍历数组。 语法格式如下：1234for(type element: array)&#123; System.out.println(element);&#125; 实例12345678910public class TestArray &#123; public static void main(String[] args) &#123; double[] myList = &#123;1.9, 2.9, 3.4, 3.5&#125;; // 打印所有数组元素 for (double element: myList) &#123; System.out.println(element); &#125; &#125;&#125; Arrays 类java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。 具有以下功能： 给数组赋值：通过 fill 方法。 对数组排序：通过 sort 方法,按升序。 比较数组：通过 equals 方法比较数组中元素值是否相等。 查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。 具体说明请查看下表： 序号 方法和说明 1 public static int binarySearch(Object[] a, Object key) 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。 2 public static boolean equals(long[] a, long[] a2) 如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 3 public static void fill(int[] a, int val) 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 4 public static void sort(Object[] a) 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 Java 日期时间 java.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。 第一个构造函数使用当前日期和时间来初始化对象。 Date( ) 第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。 Date(long millisec) Date对象创建以后，可以调用下面的方法。 序号 方法和描述 1 boolean after(Date date) 若当调用此方法的Date对象在指定日期之后返回true,否则返回false。 2 boolean before(Date date) 若当调用此方法的Date对象在指定日期之前返回true,否则返回false。 3 Object clone( ) 返回此对象的副本。 4 int compareTo(Date date) 比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。 5 int compareTo(Object obj) 若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出ClassCastException。 6 boolean equals(Object date) 当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。 7 long getTime( ) 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 8 int hashCode( ) 返回此对象的哈希码值。 9 void setTime(long time) 用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。 10 String toString( ) 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)。 获取当日时间实例1234567891011import java.util.Date; public class DateDemo &#123; public static void main(String args[]) &#123; // 初始化 Date 对象 Date date = new Date(); // 使用 toString() 函数显示日期时间 System.out.println(date.toString()); &#125;&#125; 使用 SimpleDateFormat 格式化日期 SimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。 实例123456789101112import java.util.*;import java.text.*; public class DateDemo &#123; public static void main(String args[]) &#123; Date dNow = new Date( ); SimpleDateFormat ft = new SimpleDateFormat ("yyyy-MM-dd hh:mm:ss"); //这行代码确立了转换的格式，其中 yyyy 是完整的公元年，MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。 System.out.println("当前时间为: " + ft.format(dNow)); &#125;&#125; 运行结果` Current Date: Wed 2019.03.27 at 01:07:33 PM UTC 注意: 有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。 日期和时间的格式化编码时间模式字符串用来指定时间格式。在此模式中，所有的 ASCII 字母被保留为模式字母，定义如下： 字母 描述 示例 G 纪元标记 AD y 四位年份 2001 M 月份 July or 07 d 一个月的日期 10 h A.M./P.M. (1~12)格式小时 12 H 一天中的小时 (0~23) 22 m 分钟数 30 s 秒数 55 S 毫秒数 234 E 星期几 Tuesday D 一年中的日子 360 F 一个月中第几周的周几 2 (second Wed. in July) w 一年中第几周 40 W 一个月中第几周 1 a A.M./P.M. 标记 PM k 一天中的小时(1~24) 24 K A.M./P.M. (0~11)格式小时 10 z 时区 Eastern Standard Time ‘ 文字定界符 Delimiter “ 单引号 ` 使用printf格式化日期printf 方法可以很轻松地格式化时间和日期。使用两个字母格式，它以 %t 开头并且以下面表格中的一个字母结尾。 转 换 符 说 明 示 例 c 包括全部日期和时间信息 星期六 十月 27 14:21:20 CST 2007 F “年-月-日”格式 2007-10-27 D “月/日/年”格式 10/27/07 r “HH:MM:SS PM”格式（12时制） 02:25:51 下午 T “HH:MM:SS”格式（24时制） 14:28:16 R “HH:MM”格式（24时制） 14:28 实例12345678910111213141516171819202122import java.util.Date; public class DateDemo &#123; public static void main(String args[]) &#123; // 初始化 Date 对象 Date date = new Date(); //c的使用 System.out.printf("全部日期和时间信息：%tc%n",date); //f的使用 System.out.printf("年-月-日格式：%tF%n",date); //d的使用 System.out.printf("月/日/年格式：%tD%n",date); //r的使用 System.out.printf("HH:MM:SS PM格式（12时制）：%tr%n",date); //t的使用 System.out.printf("HH:MM:SS格式（24时制）：%tT%n",date); //R的使用 System.out.printf("HH:MM格式（24时制）：%tR",date); &#125;&#125; 以上实例编译运行结果如下: 全部日期和时间信息：星期一 九月 10 10:43:36 CST 2012年-月-日格式：2012-09-10月/日/年格式：09/10/12HH:MM:SS PM格式（12时制）：10:43:36 上午HH:MM:SS格式（24时制）：10:43:36HH:MM格式（24时制）：10:43 如果你需要重复提供日期，那么利用这种方式来格式化它的每一部分就有点复杂了。因此，可以利用一个格式化字符串指出要被格式化的参数的索引。 索引必须紧跟在%后面，而且必须以$结束。 实例1234567891011121314import java.util.Date; public class DateDemo &#123; public static void main(String args[]) &#123; // 初始化 Date 对象 Date date = new Date(); // 使用toString()显示日期和时间 System.out.printf("%1$s %2$tB %2$td, %2$tY", "Due date:", date);//%1$s对应第一个索引"Due date:"，%2$tB %2$td, %2$tY"对应第二个索引 date &#125;&#125; 以上实例编译运行结果如下: Due date: February 09, 2014 或者，你可以使用 &lt; 标志。它表明先前被格式化的参数要被再次使用。： 实例12345678910111213import java.util.Date; public class DateDemo &#123; public static void main(String args[]) &#123; // 初始化 Date 对象 Date date = new Date(); // 显示格式化时间 System.out.printf("%s %tB %&lt;te, %&lt;tY", "Due date:", date); &#125;&#125; 解析字符串为时间SimpleDateFormat 类有一些附加的方法，特别是parse()，它试图按照给定的SimpleDateFormat 对象的格式化存储来解析字符串。 实例123456789101112131415161718import java.util.*;import java.text.*; public class DateDemo &#123; public static void main(String args[]) &#123; SimpleDateFormat ft = new SimpleDateFormat ("yyyy-MM-dd-hh:mm:ss"); //这里可以修改格式 String input = "2015-11-10-23:23:20" ; System.out.print(input + " Parses as "); Date t; try &#123; t = ft.parse(input); System.out.println(t); &#125; catch (ParseException e) &#123; System.out.println("Unparseable using " + ft); &#125; &#125;&#125; 运行结果 2015-11-10-23:23:20 Parses as Tue Nov 10 23:23:20 UTC 2015 Java 休眠(sleep) sleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。你可以让程序休眠一毫秒的时间或者到您的计算机的寿命长的任意段时间。 实例12345678910111213import java.util.*; public class SleepDemo &#123; public static void main(String args[]) &#123; try &#123; System.out.println(new Date( ) + "\n"); Thread.sleep(1000*3); // 休眠3秒 System.out.println(new Date( ) + "\n"); &#125; catch (Exception e) &#123; System.out.println("Got an exception!"); &#125; &#125;&#125; 运行结果 Wed Mar 27 13:52:45 UTC 2019 Wed Mar 27 13:52:48 UTC 2019 Calendar类我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，或者分钟? 我们又如何在日期的这些部分加上或者减去值呢? 答案是使用Calendar 类。 Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些. Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。 创建一个代表系统当前日期的Calendar对象 Calendar c = Calendar.getInstance();//默认是当前日期 Calendar类对象字段类型Calendar类中用以下这些常量表示不同的意义，jdk内的很多类其实都是采用的这种思想 常量 描述 Calendar.YEAR 年份 Calendar.MONTH 月份 Calendar.DATE 日期 Calendar.DAY_OF_MONTH 日期，和上面的字段意义完全相同 Calendar.HOUR 12小时制的小时 Calendar.HOUR_OF_DAY 24小时制的小时 Calendar.MINUTE 分钟 Calendar.SECOND 秒 Calendar.DAY_OF_WEEK 星期几 Calendar类对象信息的设置Set设置 Calendar c1 = Calendar.getInstance();调用：public final void set(int year,int month,int date)c1.set(2009, 6 - 1, 12);//把Calendar对象c1的年月日分别设这为：2009、6、12如果只设定某个字段，例如日期的值，则可以使用如下set方法：public void set(int field,int value)把 c1对象代表的日期设置为10号，其它所有的数值会被重新计算c1.set(Calendar.DATE,10); Add设置 Calendar c1 = Calendar.getInstance();把c1对象的日期加上10，也就是c1也就表示为10天后的日期，其它所有的数值会被重新计算c1.add(Calendar.DATE, 10);把c1对象的日期减去10，也就是c1也就表示为10天前的日期，其它所有的数值会被重新计算c1.add(Calendar.DATE, -10); GregorianCalendar类 Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。Calendar 的getInstance（）方法返回一个默认用当前的语言环境和时区初始化的GregorianCalendar对象。GregorianCalendar定义了两个字段：AD和BC。这是代表公历定义的两个时代。 下面列出GregorianCalendar对象的几个构造方法： 序号 构造函数和说明 1 GregorianCalendar() 在具有默认语言环境的默认时区内使用当前时间构造一个默认的 GregorianCalendar。 2 GregorianCalendar(int year, int month, int date) 在具有默认语言环境的默认时区内构造一个带有给定日期设置的 GregorianCalendar 3 GregorianCalendar(int year, int month, int date, int hour, int minute) 为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。 4 GregorianCalendar(int year, int month, int date, int hour, int minute, int second) 为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。 5 GregorianCalendar(Locale aLocale) 在具有给定语言环境的默认时区内构造一个基于当前时间的 GregorianCalendar。 6 GregorianCalendar(TimeZone zone) 在具有默认语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。 7 GregorianCalendar(TimeZone zone, Locale aLocale) 在具有给定语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。 这里是GregorianCalendar 类提供的一些有用的方法列表： 序号 方法和说明 1 void add(int field, int amount) 根据日历规则，将指定的（有符号的）时间量添加到给定的日历字段中。 2 protected void computeFields() 转换UTC毫秒值为时间域值 3 protected void computeTime() 覆盖Calendar ，转换时间域值为UTC毫秒值 4 boolean equals(Object obj) 比较此 GregorianCalendar 与指定的 Object。 5 int get(int field) 获取指定字段的时间值 6 int getActualMaximum(int field) 返回当前日期，给定字段的最大值 7 int getActualMinimum(int field) 返回当前日期，给定字段的最小值 8 int getGreatestMinimum(int field) 返回此 GregorianCalendar 实例给定日历字段的最高的最小值。 9 Date getGregorianChange() 获得格里高利历的更改日期。 10 int getLeastMaximum(int field) 返回此 GregorianCalendar 实例给定日历字段的最低的最大值 11 int getMaximum(int field) 返回此 GregorianCalendar 实例的给定日历字段的最大值。 12 Date getTime() 获取日历当前时间。 13 long getTimeInMillis() 获取用长整型表示的日历的当前时间 14 TimeZone getTimeZone() 获取时区。 15 int getMinimum(int field) 返回给定字段的最小值。 16 int hashCode() 重写hashCode. 17 boolean isLeapYear(int year) 确定给定的年份是否为闰年。 18 void roll(int field, boolean up) 在给定的时间字段上添加或减去（上/下）单个时间单元，不更改更大的字段。 19 void set(int field, int value) 用给定的值设置时间字段。 20 void set(int year, int month, int date) 设置年、月、日的值。 21 void set(int year, int month, int date, int hour, int minute) 设置年、月、日、小时、分钟的值。 22 void set(int year, int month, int date, int hour, int minute, int second) 设置年、月、日、小时、分钟、秒的值。 23 void setGregorianChange(Date date) 设置 GregorianCalendar 的更改日期。 24 void setTime(Date date) 用给定的日期设置Calendar的当前时间。 25 void setTimeInMillis(long millis) 用给定的long型毫秒数设置Calendar的当前时间。 26 void setTimeZone(TimeZone value) 用给定时区值设置当前时区。 27 String toString() 返回代表日历的字符串。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客：在Github上搭建Hexo博客]]></title>
    <url>%2F2019%2F03%2F23%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[具体实现看下面的链接 这里是一些链接，请享用~ Github上搭建Hexo博客 next主题视频教程 next主题安装及其设置 GitHub Corners 三月里的樱花已经悄然开放，开的如火如荼，极其美丽。翠绿的枝叶，沾有清晨的露珠，在太阳慈爱的照耀下闪闪发亮。满树烂漫的樱花林，透出了一股甜美的气息。从远处看，如云似霞般炫目，不时引来一只只彩蝶绕花盘旋，花掩蝶蝶恋花，两种景物融为一体，时常迷得依依抱着胳膊趴在树枝上暗暗陶醉。]]></content>
      <categories>
        <category>安装链接</category>
      </categories>
      <tags>
        <tag>搭建hexo博客</tag>
        <tag>next主题安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
