<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Qt实战（3）]]></title>
    <url>%2F2019%2F05%2F26%2FQt%E5%AE%9E%E6%88%98%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Qt 操作MySql数据库 配置问题：Qt连接MySQL的时候提示“QSqlDatabase: QMYSQL driver not loaded”， 解决办法： 你的Qt Creator与MySQL位数统一的情况下，从 你的MySQL\lib目录下中将 libmysql.dll 文件复制到C:\Qt\Qt5.6.1\5.6\mingw49_32\bin中。运行程序。 如果你的Qt Creator与MySQL位数不统一，下载一个位数与你的Qt相同的Mysql,找到里面的 libmysql.dll文件复制到目录下。 总之，必须保证你拿到libmysql.dll这个文件对应的mysql的位数必须与QT的位数相同。 数据库基本操作对数据库基本操作就是增、删、改、查。 新建 Qt Widgets 应用， 项目名称为 database， 类名为Mywidget， 基类选择QWidget。 完成后在 database.pro文件中添加如下代码： 1QT += sql 连接数据库，在构造函数中添加以下代码 12345678910111213141516171819202122232425262728293031#include&lt;QSqlDatabase&gt;#include&lt;QDebug&gt;#include&lt;QMessageBox&gt;#include&lt;QSqlError&gt;Widget::Widget(QWidget *parent) : QWidget(parent), ui(new Ui::Widget)&#123; ui-&gt;setupUi(this); 打印QT支持的数据库驱动 qDebug()&lt;&lt;QSqlDatabase::drivers(); //添加mysql数据库 QSqlDatabase db = QSqlDatabase::addDatabase("QMYSQL"); //连接数据库 db.setHostName("127.0.0.1"); db.setUserName("root"); db.setPassword("an1234"); db.setDatabaseName("test_db"); //打开数据库是否成功 if(!db.open()) &#123; QMessageBox::warning(this,"错误",db.lastError().text()); return; &#125; &#125; QT支持的数据库驱动有：1(&quot;QSQLITE&quot;, &quot;QMYSQL&quot;, &quot;QMYSQL3&quot;, &quot;QPSQL&quot;, &quot;QPSQL7&quot;) 创建数据表格，继续向后添加代码 123456#include&lt;QSqlQuery&gt;//一组数据//创建数据表格 QSqlQuery query; query.exec("create table student(id int primary key auto_increment ,name varchar(255),age int,score int);"); 此条语句运行一次后要注释，不能多次创建同名的数据表格 数据库的另一种操作 12345678910111213141516171819 //添加mysql数据库 a是连接名，用于区分QSqlDatabase db1 = QSqlDatabase::addDatabase("QMYSQL","a");//连接数据库db1.setHostName("127.0.0.1");db1.setUserName("root");db1.setPassword("an1234");db1.setDatabaseName("testdb");//打开数据库是否成功if(!db1.open())&#123; QMessageBox::warning(this,"错误",db.lastError().text()); return;&#125;QSqlQuery query1(db1);//有区分时，一定要加上数据库名query1.exec("create table student(id int primary key auto_increment ,name varchar(255),age int,score int);"); 插入(增) ① 插入一条数据 1234//插入数据 QSqlQuery query; query.exec("insert into student (id, name, age, score)values(2,'lucy',22,59);"); ② 批量插入两种方法：obdc风格 123456789101112131415161718192021#include&lt;QVariantList&gt;//放任何类型，列表 //obdc风格插入 //预处理语句 //？相当于占位符 query.prepare("insert into student (name, age, score)values(?,?,?);"); //给字段设置内容 QVariantList namelist; namelist &lt;&lt; "xiaoming" &lt;&lt; "xiaohua" &lt;&lt; "xiaoliao"; QVariantList agelist; agelist &lt;&lt; 19 &lt;&lt; 20 &lt;&lt; 21; QVariantList scorelist; scorelist &lt;&lt; 98 &lt;&lt; 88 &lt;&lt; 99; //给字段绑定相应的值，按顺序绑定 query.addBindValue(namelist); query.addBindValue(agelist); query.addBindValue(scorelist); //执行预处理命令 query.execBatch(); oracle风格123456789101112131415161718//oracle风格//占位符 ： + 自定义名字query.prepare("insert into student (name, age, score)values(:name, :age, :score);");//给字段设置内容QVariantList namelist;namelist &lt;&lt; "xiaoa" &lt;&lt; "xiaob" &lt;&lt; "xiaoc";QVariantList agelist;agelist &lt;&lt; 19 &lt;&lt; 20 &lt;&lt; 21;QVariantList scorelist;scorelist &lt;&lt; 98 &lt;&lt; 88 &lt;&lt; 99;//给字段绑定 可以不按照顺序query.bindValue(":name",namelist);query.bindValue(":score",scorelist);query.bindValue(":age",agelist);//执行预处理命令query.execBatch(); 更新数据（改） 12QSqlQuery query;query.exec("update student set score = 72 where id = 3"); 查找并打印（查） 12345678910QSqlQuery query;query.exec("select * from student where name = 'xiaob' ");//过滤while(query.next())//一行一行的查找，一直到没有返回false&#123; qDebug()&lt;&lt;query.value(0).toInt() &lt;&lt;query.value(1).toString() &lt;&lt;query.value("age").toInt() &lt;&lt;query.value(3).toInt();&#125; 在界面上执行删除操作（删） ①设计页面如图所示 ②右击按钮转到槽 123456789101112131415161718192021222324252627void Widget::on_buttondelete_clicked()&#123; //获取行编辑器内容 QString name = ui-&gt;lineEdit-&gt;text(); QString sql = QString("delete from student where name ='%1'").arg(name); //开启一个事务 QSqlDatabase::database()获取你操作的数据库 //事务是数据库的一个重要功能，所谓事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位。 //qDebug()&lt;&lt; QSqlDatabase::database().transaction();//有的版本不支持这种用法 QSqlQuery query; query.exec("START TRANSACTION"); query.exec(sql);&#125;void Widget::on_buttonsure_clicked()&#123; //确认删除 QSqlDatabase::database().commit();&#125;void Widget::on_buttoncancel_clicked()&#123; //回滚，撤销 qDebug()&lt;&lt;"hahahhahh"; QSqlDatabase::database().rollback();&#125; 本地数据库Sqlite 新建 Qt Widgets 应用， 项目名称为 Sqlite， 类名为Mywidget， 基类选择QWidget。 在你的Sqlite相同目录下创建文件info.db 在.pro文件中添加 1QT+= sql 操作，同mysql的操作基本一样，因为是本地数据库，所以没有连接数据库的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;QSqlDatabase&gt;#include&lt;QDebug&gt;#include&lt;QMessageBox&gt;#include&lt;QSqlError&gt;//#include&lt;QSqlQuery&gt;//一组数据#include&lt;QVariantList&gt;//放任何类型，列表MyWidget::MyWidget(QWidget *parent) : QWidget(parent), ui(new Ui::MyWidget)&#123; ui-&gt;setupUi(this); //打印QT支持的数据库驱动 qDebug()&lt;&lt;QSqlDatabase::drivers(); //添加qsqlite数据库 本地数据库 //不是很大型的数据库 QSqlDatabase db = QSqlDatabase::addDatabase("QSQLITE"); db.setDatabaseName("../info.db"); //打开数据库是否成功 if(!db.open()) &#123; QMessageBox::warning(this,"错误",db.lastError().text()); return; &#125; //创建数据表格 QSqlQuery query;//不支持自动添加id功能 query.exec("create table student(id int primary key,name varchar(255),age int,score int);"); query.prepare("insert into student (name, age, score)values(?,?,?);"); //给字段设置内容 QVariantList namelist; namelist &lt;&lt; "xiaoming" &lt;&lt; "xiaohua" &lt;&lt; "xiaoliao"; QVariantList agelist; agelist &lt;&lt; 19 &lt;&lt; 20 &lt;&lt; 21; QVariantList scorelist; scorelist &lt;&lt; 98 &lt;&lt; 88 &lt;&lt; 99; //给字段绑定相应的值，按顺序绑定 query.addBindValue(namelist); query.addBindValue(agelist); query.addBindValue(scorelist); query.execBatch(); //查找并打印 query.exec("select * from student"); while(query.next())//一行一行的查找，一直到没有返回false &#123; qDebug()&lt;&lt;query.value(0).toInt() &lt;&lt;query.value(1).toString() &lt;&lt;query.value("age").toInt() &lt;&lt;query.value(3).toInt(); &#125;&#125; QTableModel类实现对数据库的可视化操作QSqlTableModel，该类提供了一个可读写单张SQL表的可编辑数据模型。下面实际操作一下 新建 Qt Widgets 应用， 项目名称为sqlModel， 类名为Mywidget， 基类选择QWidget。 在.pro文件中添加 1QT+= sql 设计界面如图所示 注意：和里面的显示数据库的框用的是Item Views(Model-Based)里的TableView。 在头文件中添加库和对象 123456#include&lt;QSqlTableModel&gt;private: Ui::MyWidget *ui; QSqlTableModel *model; 实现可视化操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;QSqlDatabase&gt;#include&lt;QDebug&gt;#include&lt;QMessageBox&gt;#include&lt;QSqlError&gt;#include&lt;QSqlTableModel&gt;#include&lt;QSqlRecord&gt;//数据库操作记录MyWidget::MyWidget(QWidget *parent) : QWidget(parent), ui(new Ui::MyWidget)&#123; ui-&gt;setupUi(this); //添加mysql数据库 QSqlDatabase db = QSqlDatabase::addDatabase("QMYSQL"); //连接数据库 db.setHostName("127.0.0.1"); db.setUserName("root"); db.setPassword("an1234"); db.setDatabaseName("test_db"); //打开数据库是否成功 if(!db.open()) &#123; QMessageBox::warning(this,"错误",db.lastError().text()); return; &#125; //设置模型 model = new QSqlTableModel(this); model-&gt;setTable("student");//指定使用那个表 //把model放在view ui-&gt;tableView-&gt;setModel(model); //显示model里的数据 model-&gt;select(); //字段设置为指定中文名 第0个字段即id model-&gt;setHeaderData(0,Qt::Horizontal,"学号"); model-&gt;setHeaderData(1,Qt::Horizontal,"姓名"); model-&gt;setHeaderData(2,Qt::Horizontal,"年龄"); model-&gt;setHeaderData(3,Qt::Horizontal,"分数"); //设置model的编辑模式 为手动提交 model-&gt;setEditStrategy(QSqlTableModel::OnManualSubmit); //设置view中的数据库为不能修改 //ui-&gt;tableView-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers);&#125; 按钮槽函数添加代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//改//修改操作可以直接在视图框中操作//增void MyWidget::on_buttonadd_clicked()&#123; //添加空记录 QSqlRecord record = model-&gt;record(); //获取行号 int row = model-&gt;rowCount(); model-&gt;insertRecord(row,record);&#125;//删void MyWidget::on_buttondelete_clicked()&#123; //获取选中的模型 QItemSelectionModel *sModel=ui-&gt;tableView-&gt;selectionModel(); //取出选中模型中的索引（哪几行） QModelIndexList list = sModel-&gt;selectedRows(); //删除所有选中的行 for(int i=0 ;i&lt;list.size();i++) &#123; model-&gt;removeRow(list.at(i).row()); //取出所有索引中的i行的索引，再根据这个索引选中并删除这一行 &#125;&#125;void MyWidget::on_buttonsure_clicked()&#123; model-&gt;submitAll();//提交动作&#125;void MyWidget::on_buttoncancel_clicked()&#123; model-&gt;revertAll();//取消动作 model-&gt;submitAll();//提交动作（取消也是一个动作）&#125;//查void MyWidget::on_buttonsure_2_clicked()&#123; //获取行编辑器内容 QString name = ui-&gt;lineEdit-&gt;text(); //过滤条件 QString str = QString("name='%1'").arg(name); model-&gt;setFilter(str); model-&gt;select();//重新显示model里的数据&#125;]]></content>
      <categories>
        <category>界面</category>
      </categories>
      <tags>
        <tag>Qtcreator</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt实战（2）]]></title>
    <url>%2F2019%2F05%2F19%2FQt%E5%AE%9E%E6%88%98%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[TCP 和 UDP 通信 TCP 先通过一张图片了解TCP通信过程，QT的TCP Socket（套接字）通信仍然有服务端、客户端之分。图中左为客户端，右为服务端。服务端通过监听某个端口来监听是否有客户端连接到来，如果有连接到来，则建立新的SOCKET连接；客户端通过IP和PORT（端口）连接服务端，当成功建立连接之后，就可进行数据的接收和发送了。数据的收发是通过read()和write()来进行的。Socket，也就是常说的“套接字”。Socket简单地说，就是一个IP地址加一个port端口 TCP通信原理图 先来看运行结果： 服务端 新建项目，选择Qt Widgets应用，项目名为TCP_connect,类名为ServerWidget。 在 TCP_connect.pro内联网，添加以下代码，添加后先编译不运行。（之后的所有有关UDP和CDP，都要加上这句，以后不再多说。） 123QT += core gui networkCONFIG += C++11 //之后可能会用到c++中的Lambdas表达式，所以把这句也加上 设计ui界面如生成结果中的服务端 在ServerWidget.h头文件中，添加头文件并，创建监听套接字和通信套接字对象。 123456#include&lt;QTcpServer&gt; //监听套接字#include&lt;QTcpSocket&gt; //通信套接字private: QTcpServer *tcpServer;//监听套接字 QTcpSocket *tcpSocket;//通信套接字 在ServerWidget.h源文件构造函数添加以下 1234567891011121314151617181920212223242526272829303132 setWindowTitle("服务器：8888"); tcpServer=NULL; tcpSocket=NULL; //监听套接字分配空间，父窗口自动回收空间 tcpServer=new QTcpServer(this); //监听并绑定 tcpServer-&gt;listen(QHostAddress::Any,8888); //触发新连接 connect(tcpServer,&amp;QTcpServer::newConnection, [=]()&#123; //取出建立好连接的套接字并赋值给通信套接字 tcpSocket =tcpServer-&gt;nextPendingConnection();//取出下一个连接，即当前最近的一个连接 //获取对方的ip和端口(peer表示对方） QString ip=tcpSocket-&gt;peerAddress().toString();//.toIPv4Address() qint16 port = tcpSocket-&gt;peerPort();//连接成功 QString temp=QString("[%1:%2]:成功连接").arg(ip).arg(port); ui-&gt;textEditRead-&gt;setText(temp);//显示到只读窗口 //接收数据 connect(tcpSocket,&amp;QTcpSocket::readyRead, [=]()&#123; //从通信套接字中取出内容 QByteArray array= tcpSocket-&gt;readAll(); ui-&gt;textEditRead-&gt;append(array); &#125;); &#125;); 发送消息（文本）按钮和关闭连接按钮，分别右击转到槽。添加代码 1234567891011121314151617181920212223void ServerWidget::on_buttonsend_clicked()&#123; if(tcpSocket==NULL)&#123;//有套接字连接的情况下，才能进行此操作 return; &#125; //获取write编辑区内容 QString str=ui-&gt;textEditWrite-&gt;toPlainText(); //给客服端发送数据，使用tcpSocket套接字 tcpSocket-&gt;write(str.toUtf8().data());&#125;void ServerWidget::on_buttonclose_clicked()&#123; if(tcpSocket==NULL)&#123; return; &#125; //主动和客户端断开连接 tcpSocket-&gt;disconnectFromHost();//从服务器取消这个连接到它的服务器 tcpSocket-&gt;close(); tcpSocket=NULL;//断开连接后，通信套接字里面就没有内容了&#125; 客户端1.右击项目，添加c++class类，类名为clientwidget。设计ui界面如生成结果。2.在clientwidget.h头文件中添加代码,通信套接字头文件和对象。 1234#include&lt;QTcpSocket&gt; //通信套接字private: QTcpSocket *tcpsocket;//通信套接字 3.在clientwidget.cpp文件构造函数中添加代码, 12345678910111213141516171819setWindowTitle("客户端");tcpsocket=NULL;//分配空间，指定父对象tcpsocket=new QTcpSocket(this);//连接到服务器就会触发connected转到槽connect(tcpsocket,&amp;QTcpSocket::connected, [=]()&#123; ui-&gt;textEditRead-&gt;setText("成功和服务器建立好连接"); &#125;);connect(tcpsocket,&amp;QTcpSocket::readyRead, [=]()&#123; //获取对方发送的数据 QByteArray array=tcpsocket-&gt;readAll(); //显示到read编辑框中 ui-&gt;textEditRead-&gt;append(array);&#125;); 三个按钮分别右击转到槽 1234567891011121314151617181920212223242526272829#include&lt;QHostAddress&gt;//之后的操作要添加此头文件void ClientWidget::on_bottonSend_clicked()&#123; //获取write编辑框内容 QString str=ui-&gt;textEditWrite-&gt;toPlainText(); //发送数据 tcpsocket-&gt;write(str.toUtf8().data());&#125;void ClientWidget::on_buttonConnect_clicked()&#123; //从输入行编辑器获取服务器的ip和端口 QString ip=ui-&gt;lineEditIp-&gt;text(); qint16 port=ui-&gt;lineEditPort-&gt;text().toInt();//qint16代表16位的无符号整形。 //主动和服务器建立连接 tcpsocket-&gt;connectToHost(QHostAddress(ip),port);&#125;void ClientWidget::on_bottonClose_clicked()&#123; //主动和对方断开连接 tcpsocket-&gt;disconnectFromHost(); tcpsocket-&gt;close();&#125; UDP UDP（User Datagram Protocol即用户数据报协议）是一个轻量级的，不可靠的，面向数据报的无连接协议。就像我们现在使用的QQ，其聊天时就是使用UDP协议进行消息发送的。像QQ那样，当有很多用户，发送的大部分都是短消息，要求能及时响应，并且对安全性要求不是很高的情况下使用UDP协议。即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。 在Qt中提供了QUdpSocket 类来进行UDP数据报（datagrams）的发送(writeDatagram)和接收(readDatagram)。 先来看一下UDP通信过程 现在我们来创造下面如图所示的一个服务器：新建项目，选择Qt Widgets应用，项目名为udpsocket,类名为Widget。 先根据上图设计界面 在头文件中添加通信套接字声明，再定义一个对象 123#include&lt;QUdpSocket&gt;QUdpSocket *udpsocket; 分配空间和绑定端口,连接通信套接字自动触发readyRead()信号和处理的槽函数 先在头文件声明公有槽函数：1void dealMag();//槽函数，处理对方发送过来的信号。 在构造函数添加：1234567891011121314151617181920212223242526272829303132333435363738394041Widget::Widget(QWidget *parent) : QWidget(parent), ui(new Ui::Widget)&#123; ui-&gt;setupUi(this); setWindowTitle("服务端口为：8888"); //分配空间，指定父对象 udpsocket= new QUdpSocket(this); //绑定端口 udpsocket-&gt;bind(8888); //udpsocket-&gt;bind(QHostAddress::AnyIPv4,8888); //加入某个组播 //组播地址是D类地址 //udpsocket-&gt;joinMulticastGroup(QHostAddress("244.0.0.2")); //udpsocket-&gt;leaveMulticastGroup(1);//退出组播 //当对方成功发送数据过来 //自动触发readyRead()信号 connect(udpsocket,&amp;QUdpSocket::readyRead,this,&amp;Widget::dealMag);&#125;void Widget::dealMag()&#123; //读取对方发送的内容 char buf[1024]=&#123;0&#125;; QHostAddress clientAddr; //对方地址 quint16 clientPort; //对方端口 qint64 len=udpsocket-&gt;readDatagram(buf,sizeof(buf),&amp;clientAddr,&amp;clientPort); if(len&gt;0) &#123; //接收内容格式化 QString str = QString("[%1:%2] %3") .arg(clientAddr.toString()) .arg(clientPort) .arg(buf); ui-&gt;textEdit-&gt;setText(str); &#125;&#125; 两个按钮转到槽 12345678910111213141516171819202122#include&lt;QHostAddress&gt;//记得添加这个头文件void Widget::on_bottonSend_clicked()&#123; //获取对方ip和端口 QString ip=ui-&gt;lineEditIP-&gt;text(); qint16 port=ui-&gt;lineEditPort-&gt;text().toInt(); //获取编辑区数据 QString str=ui-&gt;textEdit-&gt;toPlainText(); //给指定的ip发送数据 udpsocket-&gt;writeDatagram(str.toUtf8(),QHostAddress(ip),port);&#125;void Widget::on_bottonClose_clicked()&#123; //主动和对方断开连接 udpsocket-&gt;disconnectFromHost(); udpsocket-&gt;close();&#125; 根据以上方法就可以创建很多服务端（客户端），通过绑定的端口就可以相互通信了。 UDP组播问题 因为在实际项目中，用户有N个电脑预览实时视频，如果同时有N多个终端去连接服务器，服务器的压力发送数据带宽的压力很大，所以给提出采用组播的方式去解决此类的问题。就像QQ群一样，限定人数，避免广播风暴。组播的原理大致就是服务器往某一组播地址和端口发数据，之后客户端从指定的组播地址和端口去取数据，好处就是减轻了服务器发送的压力 开启多个服务器，用客户端发送数据，所有服务器端(复制的过程)都会收到客户端发送的数据。 组播实现在上个例子代码中注释部分有，需要注意： 发送端既可以加入组播，也可以不加入组播； -吧服务端绑定的ip地址必须是ipv4地址； 组播地址必须是D类地址 TCP传输文件 先来看过传输文件程图： 运行结果： 首先看到运行结果如上图所示新建项目，选择Qt Widgets应用，项目名为tcpfile,类名为ServerWidget。 服务端 根据运行结果设计界面. ServerWidget.h 1234567891011121314151617181920212223242526272829303132333435363738394041#ifndef SERVERWIDGET_H#define SERVERWIDGET_H#include &lt;QWidget&gt;#include&lt;QTcpServer&gt;//监听套接字#include&lt;QTcpSocket&gt;//通信套接字#include&lt;QFile&gt;#include&lt;QTimer&gt;namespace Ui &#123;class ServerWidget;&#125;class ServerWidget : public QWidget&#123; Q_OBJECTpublic: explicit ServerWidget(QWidget *parent = 0); ~ServerWidget(); void sendData();private slots: void on_buttonfile_clicked();//这是转到槽自动添加的 void on_buttonsend_clicked();//这是转到槽自动添加的private: Ui::ServerWidget *ui; QTcpServer *tcpserver;//通信套接字和 QTcpSocket *tcpsocket;//监听套接字 QFile file;//文件对象 QString filename;//文件名字 qint64 filesize;//文件大小 qint64 sendsize;//已经发送文件大小 QTimer timer;//定时器&#125;;#endif // SERVERWIDGET_H ServerWidget.cpp中添加代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "serverwidget.h"#include "ui_serverwidget.h"#include&lt;QFileDialog&gt;//文件对话框#include&lt;QDebug&gt;#include&lt;QFileInfo&gt;ServerWidget::ServerWidget(QWidget *parent) : QWidget(parent), ui(new Ui::ServerWidget)&#123; ui-&gt;setupUi(this); setWindowTitle("服务器端口:8888"); //分配空间 tcpserver = new QTcpServer(this); //监听 tcpserver-&gt;listen(QHostAddress::Any,8888); //没建立连接前是不能对进行操作的 ui-&gt;buttonfile-&gt;setEnabled(false); ui-&gt;buttonsend-&gt;setEnabled(false); //自动触发newconnection connect(tcpserver,&amp;QTcpServer::newConnection, [=]() &#123; //取出建立好的连接套接字,获取ip和端口 tcpsocket = tcpserver-&gt;nextPendingConnection(); QString ip = tcpsocket-&gt;peerAddress().toString(); quint16 port = tcpsocket-&gt;peerPort();//无符号的 //格式化并显示在文本编辑框中 QString str = QString("[%1；%2] 连接成功！").arg(ip).arg(port); ui-&gt;textEdit-&gt;setText(str); //连接成功后，才能发送文件 ui-&gt;buttonfile-&gt;setEnabled(true); &#125;); connect(&amp;timer,&amp;QTimer::timeout, [=]() &#123; //关闭定时器 timer.stop(); //发送文件 sendData(); &#125;);&#125;void ServerWidget::sendData()&#123; qint64 len=0; do &#123; //每次发送数据的大小 char buf[4*1024]=&#123;0&#125;;//每次发4k len=0; //往文件中读数据 len = file.read(buf,sizeof(buf)); //发送数据，读多少发多少 len = tcpsocket-&gt;write(buf,len);//数据和最大大小 //发送数据需要累加 sendsize += len; &#125;while(len &gt; 0); //是否文件发送完毕 if(sendsize == filesize) &#123; ui-&gt;textEdit-&gt;append("文件发送完毕"); file.close(); //把客户端断开 tcpsocket-&gt;disconnectFromHost(); tcpsocket-&gt;close(); &#125;&#125; 按钮转到槽函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void ServerWidget::on_buttonfile_clicked()&#123; //获取打开文件路径 QString filePath = QFileDialog::getOpenFileName(this,"open","../"); if(false == filePath.isEmpty())//选择路径有效 &#123; filename.clear(); filesize = 0; //通过路径获取文件信息（文件名和文件大小） QFileInfo info(filePath);//构造对象 filename = info.fileName(); filesize = info.size();//qint64 //已经发送大小还为0 sendsize=0; //只读方式打开文件 //指定文件名字 file.setFileName(filePath); //打开文件 bool isok = file.open(QIODevice::ReadOnly); if(false == isok) &#123; qDebug()&lt;&lt;"只读方式打开文件失败 98"; &#125; //提示打开的文件路径 ui-&gt;textEdit-&gt;append(filePath); //打开文件后，按钮的状态 ui-&gt;buttonfile-&gt;setEnabled(false); ui-&gt;buttonsend-&gt;setEnabled(true); &#125; else &#123; qDebug()&lt;&lt;"选择文件路径出错"; &#125;&#125;void ServerWidget::on_buttonsend_clicked()&#123; //先发送文件头信息 文件名##文件大小 QString head = QString("%1##%2").arg(filename).arg(filesize); //发送头部信息 qint64 len = tcpsocket-&gt;write(head.toUtf8()); if(len &gt; 0)//头部信息发送成功 &#123; //发送真正的文件信息 //防止tcp黏包文件 //需要通过定时器 timer.start(20);//定时器开始就会自动触发timeout信号 &#125; else &#123; qDebug()&lt;&lt;"头部信息发送失败"; file.close(); ui-&gt;buttonfile-&gt;setEnabled(true); ui-&gt;buttonsend-&gt;setEnabled(false); &#125;&#125; 客户端 右击添加，class c++新文件，类名为clientwidget.设计界面 clientwidget.h中添加代码 1234567891011121314151617181920212223242526272829303132333435#include&lt;QFile&gt;#include&lt;QTimer&gt;namespace Ui &#123;class ServerWidget;&#125;class ServerWidget : public QWidget&#123; Q_OBJECTpublic: explicit ServerWidget(QWidget *parent = 0); ~ServerWidget(); void sendData();private slots: void on_buttonfile_clicked();//这是转到槽自动添加的 void on_buttonsend_clicked();//这是转到槽自动添加的private: Ui::ServerWidget *ui; QTcpServer *tcpserver;//通信套接字和 QTcpSocket *tcpsocket;//监听套接字 QFile file;//文件对象 QString filename;//文件名字 qint64 filesize;//文件大小 qint64 sendsize;//已经发送文件大小 QTimer timer;//定时器&#125;;#endif // SERVERWIDGET_H clientwidget.cpp中添加代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include "clientwidget.h"#include "ui_clientwidget.h"#include&lt;QDebug&gt;#include&lt;QMessageBox&gt;#include&lt;QHostAddress&gt;clientWidget::clientWidget(QWidget *parent) : QWidget(parent), ui(new Ui::clientWidget)&#123; ui-&gt;setupUi(this); setWindowTitle("客户端"); tcpsocket = new QTcpSocket(this); //ui-&gt;progressBar-&gt;setValue(0);//当前值 isstart = true;//用来判断接受的是不是头部 //连接成功准备接收文件 connect(tcpsocket,&amp;QTcpSocket::readyRead, [=]() &#123; //取出接受的内容 QByteArray buf = tcpsocket-&gt;readAll(); if(true == isstart)//第一次发的头，接收头 &#123; isstart = false; //取出接收的内容(拆包) filename = QString(buf).section("##",0,0); filesize = QString(buf).section("##",1,1).toInt(); //开始收到的文件大小为0 receivesize=0; //打开文件 file.setFileName(filename); bool isok=file.open(QIODevice::WriteOnly); if(false == isok) &#123; qDebug()&lt;&lt;"writeonly error"; &#125; &#125; else//取出文件数据 &#123; qint64 len = file.write(buf); receivesize += len; if(receivesize==filesize)//文件接受完成 &#123; //给服务器发送接收完成信息 tcpsocket-&gt;write("file done"); QMessageBox::information(this,"完成","文件接受完成！"); tcpsocket-&gt;disconnectFromHost();//断开连接 tcpsocket-&gt;close(); &#125; &#125; &#125;);&#125; 按钮转到槽 12345678void clientWidget::on_bottonconnect_clicked()&#123; //获取服务器的ip和端口 QString ip=ui-&gt;lineEditip-&gt;text(); quint16 port = ui-&gt;lineEditport-&gt;text().toInt(); tcpsocket-&gt;connectToHost(QHostAddress(ip),port);&#125; 主函数添加为： 123456789101112131415#include "serverwidget.h"#include &lt;QApplication&gt;#include"clientwidget.h"int main(int argc, char *argv[])&#123; QApplication a(argc, argv); ServerWidget w; w.show(); clientWidget w2; w2.show(); return a.exec();&#125; 心得 在学完上面的四个知识后，我写了一个实现两个pc机之间互相通信的程序，一个简单的聊天室，运行结果如下图，另一端改变绑定端口即可，使用的UDP协议，可以实现发文字消息和传输文件（文件对方接收后可以直接创建，但只能写一部分进去，我一直以为是文件写入有问题，后来才找出是我发文件的这一端发送文件大小小于实际文件大小，然后拖着拖着就难得去改了（优秀）），里面最大的问题是判断你接受的是文件还是文字问题，然后我用了分片（section）加关键字（file 和 text）区分。之后我会把我的代码上传到码云，这里不再说明过程。]]></content>
      <categories>
        <category>界面</category>
      </categories>
      <tags>
        <tag>Qtcreator</tag>
        <tag>TCP</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt实战（1）]]></title>
    <url>%2F2019%2F05%2F06%2FQt%E5%AE%9E%E6%88%98%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Qt实战 通过两个独立窗口的切换来学习信号和槽创建项目 新建Qt Widgets应用,项目名称SingelAndSlot ,类名默认为mainWidget,基类默认为QWidget,不勾选创建界面。 先来认识SingelAndSlot.pro文件： 1234567891011121314151617#添加模块QT += core gui#高于4版本，添加QT += widgets，为了兼容Qt4greaterThan(QT_MAJOR_VERSION, 4): QT += widgets#应用程序的名字TARGET = SingelAndSlot#指定SingelAndSlot的类型为appTEMPLATE = app#源文件 .cpp文件SOURCES += main.cpp\ mainwidget.cpp#头文件 .h文件HEADERS += mainwidget.h 创建两个按钮：mainwidget.h中添加代码： 123private: QPushButton b1; QPushButton *b2; mainwidget.cpp中添加：123456b1.setParent(this);b1.setText(("close");b1.move(100,100);b2=new QPushButton(this);//b2是指针，要分配存储空间b2-&gt;setText("abc"); connect函数用法：connect( 信号发出者， &amp;发出者类型::信号名字，接受者(this)，&amp;接受者类名::槽函数名字)说明： 信号发送者和接受者均为指针类型（非指针类型添加“&amp;”符号） 槽函数，即信号处理函数 如果是自定义的槽函数，需要注意以下几点： 可以是任意的成员函数，普通全局函数，静态函数； 槽函数需要和信号一致（返回值，参数）； 由于信号都是没有返回值的，所以，槽函数一定没有返回值； 添加b1的槽函数MainWidget.cpp中的构造函数中继续添加： 1connect(&amp;b1,&amp;QPushButton::pressed,this,&amp;MainWidget::close); 代码实现点击b1按钮，主窗口关闭。 添加b2的槽函数在mainwidget.h中添加自定义公有槽函数成员： 1void myslot(); MainWidget.cpp中的构造函数中添加：123//b2本来就是指针（地址），不需添加地址符connect(b2,&amp;QPushButton::released,this,&amp;MainWidget::myslot);connect(b2,&amp;QPushButton::released,&amp;b1,&amp;QPushButton::hide); MainWidget.cpp中添加函数定义：123void MainWidget::myslot()&#123; b2-&gt;setText("123");&#125; 以上代码实现释放b2按钮，主窗口实现自定义槽函数，修改按钮b2的内容，b1按钮实现按钮隐藏。 创建新窗口 头文件右击添加新文件，选择c++ class,类名为subwidget,基类为Widget。 在主窗口的头文件中添加按钮a3,源文件中添加代码： 12345b3.setParent(this);b3.setText("切换到父窗口");b3.move(50,50); resize(300,400);//窗口大小设置 在子窗口文件头文件添加按钮成员b,源文件中添加代码：12345this-&gt;setWindowTitle("我是小弟");b.setParent(this);b.setText("切换到主窗口");resize(300,400); 切换槽函数 主窗口切换为子窗口。 ① 头文件中添加公有函数成员：1void changeWin();//切换窗口 ② 添加槽函数连接和定义：1234567891011//构造函数中添加 connect(&amp;b3,&amp;QPushButton::released,this,&amp;MainWidget::changeWin); //函数定义void MainWidget::changeWin()&#123; //子窗口显示 w.show(); //主窗口隐藏 this-&gt;hide();&#125; 子窗口切换为主窗口 子窗口发送信号 信号必须有signals关键字 信号没有返回值，但可以有参数 信号就是函数的声明，只需声明，无需定义 使用 emit mysignel(); 信号可以重载 ① 在子窗口头文件中添加公有信号处理函数和信号成员 1234void sendSlot();signals: void mysignal(); ② 在子窗口源文件中添加连接及其信号处理函数：1234567//子窗口构造函数中添加 connect(&amp;b,&amp;QPushButton::clicked,this,&amp;subWidget::sendSlot);void subWidget::sendSlot()&#123; emit mysignal();//发送信号&#125; ③ 在主窗口中添加处理信号函数： 1void dealsubSignal(); ④ 在主窗口的源文件中创建信号和槽函数的连接 和处理函数的定义123456789 //处理主窗口信号 connect(&amp;w,&amp;subWidget::mysignal,this,&amp;MainWidget::dealsubSignal); void MainWidget::dealsubSignal()&#123; //子窗口隐藏 w.hide(); //主窗口显示 this-&gt;show();&#125; 这里解释一下：其实这里不是在子窗口中响应子窗口按钮发出的信号，而是通过主窗口来处理信号，只是他的信号发送方是子窗口，但要通过按钮实现，所以按下子窗口的按钮后的调用函数，函数执行的事件是发送一个信号给主窗口，这个信号属于子窗口。主窗口在对信号进行处理。 带参数的信号 在子窗口继续添加一个带参信号： 123signals: void mysignal(); void mysignal(int,QString); 在前面按钮按下而发送信号的函数里继续添加发送信号： 1234void subWidget::sendSlot()&#123; emit mysignal(); emit mysignal(250,"我是子窗口");&#125; 在主窗口里添加信号处理函数 1void dealSlot(int,QString); 信号连接和处理函数定义： 123456 connect(&amp;w,&amp;subWidget::mysignal,this,&amp;MainWidget::dealSlot); //信号处理函数 void MainWidget::dealSlot(int a, QString str)&#123; qDebug()&lt;&lt;a&lt;&lt;str.toUtf8().data();&#125; 运行程序，发现报错，这是为什么呢？因为connect里的参数&amp;subWidget::mysignal不知道是含参信号函数还是不含参信号函数啊 解决办法有两种：① 函数指针 12345void (subWidget::*withnotcansignal)()=&amp;subWidget::mysignal; connect(&amp;w,withnotcansignal,this,&amp;MainWidget::dealsubSignal); void (subWidget::*withcansignal)(int,QString)=&amp;subWidget::mysignal; connect(&amp;w,withcansignal,this,&amp;MainWidget::dealSlot); 注意： 加上作用域 ② SIGNAL和SLOT(这是qt4的信号连接，安全性不好) 123//Qt4connect(&amp;w,SIGNAL(mysignal()),this,SLOT(dealsubSignal()));connect(&amp;w,SIGNAL(mysignal(int,QString)),this,SLOT(dealSlot(int,QString))); Lamda表达式直接处理信号 在.pro项目文件中添加 1CONFIG +=C++11 在主窗口的源文件中继续添加 123456789101112131415QPushButton *b4=new QPushButton(this); b4-&gt;setText("lambda表达式"); b4-&gt;move(150,150); //[]里面放你要对外部那些变量进行操作的变量，否则无法捕捉到， //一般最好用“=”表示外面所有局部变量、类中所有成员以值传递方式（就像拷贝一样） //()传参,如果这个函数要处理的信号有参数，那括号里需要包含所传参数 //mutable允许对传入的成员进行操作，否则只读 int a=2; connect(b4,&amp;QPushButton::released, [=]()mutable &#123; b4-&gt;setText("123"); a=11; &#125;); Lamda表达式可以创造一个对信号直接处理的函数，不需要重声明和定义一个函数 创建一个主窗口创建项目 新建Qt Widgets应用,项目名称QWindow ,类名默认MainWindow,基类默认为QMainWindow,不勾选创建界面。 mainwindow.cpp代码如下，根据代码领会，不在解释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include "mainwindow.h"#include&lt;QMenuBar&gt;#include&lt;QMenu&gt;#include&lt;QAction&gt;#include&lt;QDebug&gt;#include&lt;QToolBar&gt;#include&lt;QPushButton&gt;#include&lt;QStatusBar&gt;#include&lt;QLabel&gt;#include&lt;QTextEdit&gt;#include&lt;QDockWidget&gt;#include&lt;QDialog&gt;#include&lt;QMessageBox&gt;#include&lt;QFileDialog&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; //创建菜单栏 QMenuBar *mybar=menuBar(); // 添加菜单 QMenu *pFile=mybar-&gt;addMenu("文件"); // 添加菜单项，添加动作 QAction *pNew=pFile-&gt;addAction("新建"); connect(pNew,&amp;QAction::triggered, [=]() &#123; qDebug()&lt;&lt;"新建被按下"; &#125;); pFile-&gt;addSeparator();//添加分割线 QAction *pOpen= pFile-&gt;addAction("打开"); connect(pOpen,&amp;QAction::triggered, [=]() &#123; qDebug()&lt;&lt;"打开被按下"; &#125;); //工具栏,菜单项的快捷方式 QToolBar *toolbar=addToolBar("ToolBar"); //工具栏添加快捷键 toolbar-&gt;addAction(pNew); //工具栏添加按钮控件 QPushButton *b=new QPushButton(this); b-&gt;setText("工具按钮"); toolbar-&gt;addWidget(b); connect(b,&amp;QPushButton::clicked, [=]() &#123; b-&gt;setText("哈哈哈"); &#125;); //状态栏 QStatusBar *sBar=statusBar(); QLabel *label=new QLabel(this); label-&gt;setText("程序正在运行"); sBar-&gt;addWidget(label); //addWidget从左往右添加 sBar-&gt;addWidget(new QLabel("2",this)); //从右向左添加 sBar-&gt;addPermanentWidget(new QLabel("3",this)); //核心控件 QTextEdit *textedit=new QTextEdit(this); setCentralWidget(textedit); //浮动窗口 QDockWidget *dockwidget=new QDockWidget(this); addDockWidget(Qt::RightDockWidgetArea,dockwidget); // 设置浮动窗口内容 QTextEdit *textedit1=new QTextEdit(this); dockwidget-&gt;setWidget(textedit1); //模态与非模态对话框 setMenuBar(mybar); QMenu *menu1=mybar-&gt;addMenu("对话框"); QAction *p1=menu1-&gt;addAction("模态对话框"); connect(p1,&amp;QAction::triggered, [=]() &#123; QDialog dlg; dlg.exec();//一直运行，直到用户操作 &#125;); QAction *p2=menu1-&gt;addAction("非模态对话框"); connect(p2,&amp;QAction::triggered, [=]() &#123; //这种用法导致，点击非模态对话框，对话框闪现后就被释放// QDialog dlg;// dlg.show(); //运行结束时才会释放，所以你点击多少次，就会创建多少个程序， //你关闭这个对话框时他分配到空间也不会释放// QDialog *dlg1=new QDialog(this);// dlg1-&gt;show(); //每次点击关闭内存空间就会释放 QDialog *dlg2=new QDialog(this); dlg2-&gt;setAttribute(Qt::WA_DeleteOnClose); dlg2-&gt;show(); &#125;); mybar-&gt;addSeparator();//添加分割线 QAction *p3=menu1-&gt;addAction("关于对话框"); connect(p3,&amp;QAction::triggered, [=]() &#123; QMessageBox::about(this,"about","关于Qt"); &#125;); QAction *p4=menu1-&gt;addAction("问题对话框"); connect(p4,&amp;QAction::triggered, [=]() &#123; int ret=QMessageBox::question(this,"question", "Are you ok?", QMessageBox::Ok|QMessageBox::Cancel); switch(ret) &#123; case QMessageBox::Ok: qDebug()&lt;&lt;"i am ok"; break; case QMessageBox::Cancel: qDebug()&lt;&lt;"i am bad"; break; default: break; &#125; &#125;); QAction *p5=menu1-&gt;addAction("文件对话框"); connect(p5,&amp;QAction::triggered, [=]() &#123; QString path=QFileDialog::getOpenFileName( this, "open", "../", "souce(*.cpp .h);;" "Text(*.text);;" "all(*.*)"); qDebug()&lt;&lt;path; &#125;);&#125;MainWindow::~MainWindow()&#123;&#125; 运行结果如图： Qt样式表Qt样式表Qt样式表样式大全]]></content>
      <categories>
        <category>界面</category>
      </categories>
      <tags>
        <tag>Qtcreator</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QtCreator学习（3）]]></title>
    <url>%2F2019%2F05%2F04%2FQtCreator%E5%AD%A6%E4%B9%A0%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[应用程序主窗口 应用程序主窗口关系图： 主窗口框架 主窗口为建立应用程序用户界面提供了一个框架，Qt提供了QMainWindow和其他一些相关类共同完成主窗口的管理。QMainWindow类拥有自己的布局，包含以下部件： 菜单栏(QMenuBar)。菜单栏包含了一个下拉菜单项的列表,这些菜单项由QAction动作类实现。菜单栏位于主窗口的顶部,一个主窗口只能有一个菜单栏。 工具栏(QToolBar)。工具栏一般用于显示一一些常用的菜单项目,也可以插入其他窗口部件,并且是可以移动的。一个主窗口可以拥有多个工具栏。 中心部件(Central Widget)。在主窗口的中心区域可以放入一个窗口部件作为中心部件,是应用程序的主要功能实现区域。一个主窗口只能拥有一个中心部件。 Dock部件(QDockWidget)。Dock 部件常被称为停靠窗口,因为可以停靠在中心部件的四周,用来放置- -些部件来实现- -些功能,就像个工具箱一样。一个主窗口可以拥有多个Dock部件。 状态栏(QStatusBar)。状态栏用于显示程序的一.些状态信息,在主窗口的最底部。一个主窗口只能拥有一个状态栏。 本节知识可以在帮助索引中通过Application Main Window关键字查看。 Qt资源系统、菜单栏和工具栏 新建Qt Widgets应用,项目名称mymainwindow ,类名默认为MainWindow,基类默认为QMainWindow,不改动。建立好项目后,在文件列表中双击mainwindow. ui文件进人设计模式,这时在设计区域出现的便是主窗口界面。下面来添加菜单,双击左上角的“在这里输人”,修改为“文件(&amp;F)”,这里要使用英文半角的括号,“&amp;F”被称为加速键,表明程序运行时可以按下Alt+F键来激活该菜单。修改完成后按下回车键,并在弹出的下拉菜单中将第一项改为“新建文件(&amp;N)”,并按下回车键(由于版本原因，如果这里无法直接输人中文,则可以通过复制粘贴完成),这时可以看到，下面的Action编辑器中已经有了“新建文件”动作。选中该动作并将其拖入菜单栏下面的工具栏中。运行程序 为菜单添加图标： 使用资源 这里将使用Qt的资源系统来存储图片,就可以嵌人到可执行文件之中了。避免图片位置发生变化,程序将无法显示图片这个问题。步骤如下: 添加Qt资源文件。往项目中添加新文件,选择Qt分类中的Qt ResourceFile,文件名称改为myimages,其他选项默认即可。 添加资源。建立好资源文件后会默认进人资源管理界面，打开myimages.qrc文件。现在先到项目文件夹mymainwindow中新建一个名为images的文件夹,并在其中放人两张图标图片,比如放人了一个new. png和一个open. png图片。(注意:Qt资源系统要求资源文件必须放在与qre文件同级或子级目录下，如果放在其他地方,则添加资源时会提示将文件复制到有效的位置。) 回到QtCreator中，在资源管理界面单击“添加”按钮,选择“添加前缀”,然后将属性栏中的前缀改为“/image”,再单击“添加”按钮选择添加文件”,在弹出的对话框中进人到前面新建的images文件夹中,选中那两张图片,单击“打开”即可。这时myimages. qre文件中就出现了添加的图片列表。最后,按下Ctrl+S快捷键保存对文件的修改(注意:这一点很重要,如果没有保存,下面使用图片时将看不到图片)。 使用图片。先使用Ctrl+ Tab快捷键转到mainwindow. ui文件.回到设计模式(如果先前没有打开过mainwindow. ui文件,那么该快捷键无法切换,需要直接双击该文件进行打开)。在Action编辑器中双击“新建文件”动作,这时会弹出编辑动作对话框。将对象名称改为action_New,工具提示ToolTip改为“新建文件”,然后按下“图标”后面的按钮进人选择资源界面。第一次进入该界面时,如果没有显示可用的资源,则可以单击左上角的重新加载绿色箭头图标 ,这时图片资源就显示出来了。这里选择new.png图片并单击OK按钮。最后在快捷键Shortcut后面的输入栏上单击并按下Ctrl+N组合键.就可以将它设为这个动作的快捷键了。这样就为动作添加了图标和快捷键,单击OK按钮关闭对话框。因为设置了工具提示，所以运行程序时可以将鼠标停在工具栏的一个动作上来显示提示信息。 编写代码方式添加菜单 下面使用代码来添加一个菜单,在mainwindow. cpp文件的MainWin-dow类构造函数中添加代码: 12345678QMenu *editMenu=ui-&gt;menuBar-&gt;addMenu(tr("编辑(&amp;E)")); //添加编辑菜单QAction *action_Open=editMenu-&gt;addAction( QIcon(":/image/images/open.png"),tr("打开文件(&amp;O)")); //添加打开菜单QAction *action_Open2=editMenu-&gt;addAction( QIcon(":/image/images/open.png"),tr("删除文件(&amp;D)"));action_Open-&gt;setShortcut(QKeySequence("ctrl+O")); //设置快捷键ui-&gt;mainToolBar-&gt;addAction(action_Open); //在工具栏中添加动作ui-&gt;mainToolBar-&gt;addAction(action_Open2); 这里使用ui→menuBar来获取QMainWindow的菜单栏,使用ui→mainToolBar来获取QMainWindow的工具栏,然后分别使用相应的函数添加菜单和动作 菜单栏 QMenu中还提供了间隔器.可以在设计器中向添加菜单那样直接添加间隔器,或者在代码中使用addSeparator()函数来添加,它是一条水平线，可以将菜单进行分组,使得布局很整齐。应用程序中很多普通的命令都是通过菜单来实现的，而我们也希望能将这些菜单命令放到工具栏中以方便使用。QAction 就是这样一种命令动作，可以同时放在菜单和工具栏中。一个QAction动作包含了图标、菜单显示文本、快捷键、状态栏显示文本、“What’s This?”显示文本和工具提示文本。这些都可以在构建QAction类对象时在构造函数中指定。另外,还可以设置QAction的checkable属性,如果指定这个动作的checkable为true,那么选中这个菜单时就会在它的前面显示小圆点之类的表示选中状态的符号;如果该菜单有图标.就会用线框将图标围住.用来表示该动作被选中了。 下面再介绍一个动作组QActionGroup类。它可以包含一组动作QAction,可以设置这组动作中是否只能有一个动作处于选中状态,这对于互斥型动作很有用。在前面程序的MainWindow类构造函数中继续添加如下代码: 123456789101112QActionGroup *group=new QActionGroup(this); //建立动作组QAction *action_L=group-&gt;addAction(tr("左对齐(&amp;L)")); //向动作组中添加动作action_L-&gt;setCheckable(true); //设置动作有选中和未选中状态QAction *action_R=group-&gt;addAction(tr("右对齐(&amp;R)"));action_R-&gt;setCheckable(true);QAction *action_C=group-&gt;addAction(tr("居中对齐(&amp;C)"));action_C-&gt;setCheckable(true);action_L-&gt;setChecked(true); //指定初始action_L为默认选中状态editMenu-&gt;addSeparator(); //向菜单中添加间隔器editMenu-&gt;addAction(action_L); //向编辑菜单中添加动作editMenu-&gt;addAction(action_R);editMenu-&gt;addAction(action_C); 工具栏 工具栏QToolBar类提供了一-个包含了一组控件的、可以移动的面板。前面已经看到可以将QAction对象添加到工具栏中,默认只是显示一个动作的图标，可以在QToolBar的属性栏中进行更改。在设计器中查看QToolBar的属性栏： toolButtonStyle属性用来设置图标和相应文本的显示及其相对位置; movabel属性用来设置状态栏是否可以移动; allowedArea用来设置允许停靠的位置; iconsize属性用来设置图标的大小; floatable属性用来设置是否可以悬浮。 工具栏中除了可以添加动作外,还可以添加其他的窗口部件,下面在前面的程序中的mainwindow.cpp文件中添加头文件: 12#include&lt;QToolButton&gt;#include&lt;QSpinBox&gt; 在构造函数中继续添加代码 12345678910QToolButton *toolBtn=new QToolButton(this); //创建QToolButtontoolBtn-&gt;setText(tr("颜色"));QMenu *colorMenu=new QMenu(this); //创建一个颜色菜单colorMenu-&gt;addAction(tr("红色"));colorMenu-&gt;addAction(tr("绿色"));toolBtn-&gt;setMenu(colorMenu); //为工具栏添加菜单toolBtn-&gt;setPopupMode(QToolButton::MenuButtonPopup); //设置弹出模式ui-&gt;mainToolBar-&gt;addWidget(toolBtn); //向工具栏中添加QToolButton按钮QSpinBox *spinBox=new QSpinBox(this); //创建QSpinBoxui-&gt;mainToolBar-&gt;addWidget(spinBox); //向工具栏中添加QSpinBox部件 这里创建了一个QToolButton类对象,并为它添加了一个弹出菜单,设置了弹出方式是在按钮旁边有一个向下的小箭头,可以按下这个箭头弹出菜单(默认的弹出方式是按下按钮一段时间才弹出菜单)。最后将它添加到了工具栏中。下面又在工具栏中添加了一个QSpinBox部件,可以看到，往工具栏中添加部件可以使用addWidget()函数。 这里还要再说明一下QToolButton类。其实,当往工具栏中添加一个QAction类对象时就会自动创建了一个QToolButton实例，所以说工具栏上的动作就是一个QToolButton,这就是属性栏中会有toolButtonStyle的原因。 以上运行结果如图所示： 中心部件 主窗口的中心区域可以放置一个中心部件,它一般是一个编辑器或者浏览器。这里支持单文档部件,也支持多文档部件。一般的，我们会在这里放置一个部件,然后使用布局管理器使其充满整个中心区域，并可以随着窗口的大小变化而变化。下面在前面的程序中添加中心部件。在设计模式中,往中心区域拖人一个Text Edit,然后单击界面,按下Ctrl+G,使其处于一个栅格布局中。现在可以运行程序查看效果。 QTextEdit是一个高级的WYSIWYG(所见即所得)浏览器和编辑器，支持富文本的处理,为用户提供了强大的文本编辑功能。 与QTextEdit对应的是QPlainTextEdit类,它提供了一个纯文本编辑器,这个类与QTextEdit类的很多功能都很相似,只不过无法处理富文本。 还有一个QTextBrowser类,它是一一个富文本浏览器,可以看作是QTextE-dit的只读模式。 这3个类的用法大同小异。 中心区域还可以使用多文档部件。Qt中的QMdiArea部件就是用来提供一个可以显示MDI( Multiple Document Interface)多文档界面的区域,从而有效地管理多个窗口。QMdiArea中的子窗口由QMdiSubWindow类提供,这个类有自己的布局,包含一个标题栏和一个中心区域,可以向它的中心区域添加部件。 下面更改前面的程序,在设计模式将前面添加的TextEdit部件删除，然后拖入一个MDI Area部件。在Action编辑器中的“新建文件”动作上右击,在弹出的级联菜单中选择“转到槽”,然后在弹出的对话框中选择triggered()触发信号,单击OK按钮后便转到mainwindow. cpp文件中的该信号的槽的定义处,更改如下: 123456789void MainWindow::on_action_New_triggered()&#123; //新建文本编辑器 QTextEdit *edit=new QTextEdit(this); //使用QMdiArea类的addSubWindow()函数创建子窗口，以文本编辑器为中心部件。 QMdiSubWindow *child=ui-&gt;mdiArea-&gt;addSubWindow(edit); child-&gt;setWindowTitle(tr("多文档编辑器子窗口")); child-&gt;show();&#125; 这里需要先添加井include &lt; QTextEdit&gt;和井include &lt; QMdiSubWindow&gt;头文件在新建文件菜单动作的触发信号槽on_action_New_trigered()中创建了多文档区域的子窗口。这时运行程序,然后按下工具栏上的新建文件动作图标,每按下一次，就会生成一个子窗口,如图所示。 Dock部件 QDockWidget类提供了这样一个部件,可以停靠在QMainWindow中,也可以悬浮起来作为桌面顶级窗口,称为Dock部件或者停靠窗口。Dock部件一般用于存放一些其他部件来实现特殊功能,就像一个工具箱。在主窗口中可以停靠在中心部件的四周，也可以悬浮起来被拖动到任意的地方,还可以被关闭或隐藏起来。一个Dock部件包含一个标题栏和一个内容区域,可以向Dock部件中放人任何部件。 在设计模式中向中心区域拖入一个Dock Widget 部件,然后再向Dock中随意拖人几个部件,比如这里拖入一个Push Button和一个Font Combo Box。在dock Widget的属性栏中更改其windowTitle为“工具箱”,另外还可以设置它的features属性,包含是否可以关闭、移动和悬浮等;还有allowedArea属性,用来设置可以停靠的区域。 下面在文件菜单中添加“显示Dock” 菜单项,然后在Action 编辑器中转到“显示Dock”动作的触发信号triggered()的槽函数,更改如下:1234void MainWindow::on_action_Dock_triggered()&#123; ui-&gt;dockWidget-&gt;show();&#125; 运行程序，关闭Dock部件后，按下显示Dock这个菜单项，就可以从新显示Dock了，运行结果如图： 状态栏 QStatusBar类提供了一个水平条部件,用来显示状态信息。QMainWindow 中默认提供了一个状态栏。状态信息可以被分为3类: 临时信息,如一般的提示信息; 正常信息,如显示页数和行号; 永久信息，如显示版本号或者日期。 显示函数： 使用showMessage()函数显示一个临时消息,它会出现在状态栏的最左边。 用addWidget()函数添加一个QLabel到状态栏上,用于显示正常信息,它会生成到状态栏的最左边,可能被临时消息掩盖。 显示永久信息，则要使用addPermanentWidget()函数来添加一.个如QLabel–样的可以显示信息的部件,它会生成在状态栏的最右端,不会被临时消息掩盖。 状态栏的最右端还有一个QSizeGrip部件,用来调整窗口的大小，可以使用set-SizeGripEnabled()函数来禁用它。因为目前的设计器还不支持直接向状态栏中拖放部件,所以需要使用代码来生成。向mainwindow.cpp文件中的构造函数里继续添加代码: 12345678#include &lt;QLabel&gt; //显示临时消息，时长为20000毫秒 ui-&gt;statusBar-&gt;showMessage(tr("欢迎使用多文档编辑器"),20000); //创建标签，设置标签样式和显示信息，将其以永久部件形式添加到状态栏 QLabel *permanent=new QLabel(this); permanent-&gt;setFrameStyle(QFrame::Box|QFrame::Sunken); permanent-&gt;setText("www.qter.org"); ui-&gt;statusBar-&gt;addPermanentWidget(permanent); 此时运行程序可以发现“欢迎使用多文档编辑器”字符串在显示一会儿后就自动消失了,而“www. qter. org”一直显示在状态栏最右端。如图所示： 自定义菜单 Qt中的QWidgetAction类就提供了在菜单中使用其他部件功能。为了实现自定义菜单,需要新建一个类，它继承自QWidgetAction 类,并且在其中重新实现create-Widget()函数。下面的例子中实现了这样一个菜单项:包含一个标签和一个行编辑器,可以在行编辑器中输人字符串,按下回车键就可以自动将字符串输入到中心部件文本编辑器中。 新建Qt Widgets应用,项目名称为myaction,类名默认为MainWindow ,基类默认为QMainWindow不改动。建好项目后往项目中添加新文件模板选择C++ Class, 类名设置为MyAction,基类设置为QWidgetAction。 myaction.h中添加代码： 12345678910111213141516171819202122232425#ifndef MYACTION_H#define MYACTION_H#include&lt;QWidgetAction&gt;class QLineEdit; //前置声明class MyAction : public QWidgetAction&#123; Q_OBJECTpublic: explicit MyAction(QObject *parent=0);protected: //声明函数，该函数是QWidgetAction类中的虚函数 QWidget *createWidget(QWidget *parent);signals: //新建信号，用于在按下回车键时，将行编辑器中的内容发射出去 void getText(const QString &amp;string);private slots: //新建槽，它用来与行编辑器的按下回车键信号关联 void sendText();private: //声明行编辑器对象的指针 QLineEdit *lineEdit;&#125;;#endif // MYACTION_H myaction.cpp中添加代码： 1234567891011121314151617181920212223242526272829303132333435#include "myaction.h"#include&lt;QLineEdit&gt;#include&lt;QSplitter&gt;#include&lt;QLabel&gt;MyAction::MyAction(QObject *parent): QWidgetAction(parent)&#123; //创建行编辑器 lineEdit=new QLineEdit; //将行编辑器按下回车键信号与发送文本槽关联 connect(lineEdit,&amp;QLineEdit::returnPressed,this,&amp;MyAction::sendText);&#125;QWidget *MyAction::createWidget(QWidget *parent)&#123; //这里使用inherits()函数判断父部件（是否继承）是否是菜单或工具栏 //如果是，则创建该父部件的子部件，并返回子部件 //如果不是，则直接返回0 if(parent-&gt;inherits("QMenu")||parent-&gt;inherits("QToolBar"))&#123; QSplitter *splitter = new QSplitter(parent);// 创建分裂器 QLabel *label=new QLabel; label-&gt;setText(tr("插入文本：")); splitter-&gt;addWidget(label); splitter-&gt;addWidget(lineEdit); return splitter; &#125; return 0;&#125;void MyAction::sendText()&#123; emit getText(lineEdit-&gt;text());//发射信号，将行编辑器中的内容发射出去 lineEdit-&gt;clear(); //清空行编辑器中的内容&#125; 双击mainwindow.ui文件进入设计模式，向中心区域拖入一个Text Edit部件，并使用ctrl+G使其处于一个栅格布局中。 在mainwindow.h中添加代码： 1234567891011121314151617181920212223#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;namespace Ui &#123;class MainWindow;&#125;class MainWindow : public QMainWindow&#123; Q_OBJECTpublic: explicit MainWindow(QWidget *parent = 0); ~MainWindow();private: Ui::MainWindow *ui;private slots: void setText(const QString &amp;string);&#125;;#endif // MAINWINDOW_H 在mainwindow.cpp中添加代码： 1234567891011121314151617181920212223#include "mainwindow.h"#include "ui_mainwindow.h"#include "myaction.h"MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); MyAction *action =new MyAction; QMenu *editMenu=ui-&gt;menuBar-&gt;addMenu(tr("编辑(&amp;E)")); editMenu-&gt;addAction(action); connect(action,SIGNAL(getText(QString)),this,SLOT(setText(QString)));&#125;MainWindow::~MainWindow()&#123; delete ui;&#125;void MainWindow::setText(const QString &amp;string)&#123; ui-&gt;textEdit-&gt;setText(string);//将获取的文本添加到编辑器中&#125; 现在运行程序,在编辑菜单中单击自定义的菜单动作,然后输人字符并按下回车键,可以看到输人的字符自动添加到了文本编辑器中。这个例子中设计了自己的信号和槽，整个过程是这样的:在行编辑器中输人文本，然后按下回车键,这时行编辑就会发射returnPressed()信号,而这时就调用了我们的sendText()槽,在sendText()槽中又发射了getText()信号,信号中包含了行编辑器中的文本,接着又会调用setText()槽,在setText()槽中将getText()信号发来的文本输人到文本编辑器中。这样就完成了按下回车键将行编辑器中的文本输人到中心部件的文本编辑器中的操作。 富文本处理 富文本(Rich Text)或者叫富文本格式,简单来说就是在文档中可以使用多种格式,比如字体颜色、图片和表格等。它是与纯文本(Plain Text)相对而言的，比如Windows.上的记事本就是纯文本编辑器,而Word就是富文本编辑器。Qt中提供了对富文本处理的支持,可以在帮助中通过Rich Text Processing关键字查看。 富文本文档结构富文本处理： 编辑操作-&gt;基于光标的一些接口函数-&gt;textCursor()函数-&gt;基于QTextCursor类 QTextFrameFormat QTextBlockFormat QTextTableFormat QTextListFormat 只读操作-&gt;基于文档结构，使用了只读的分层次的接口函数-&gt;document()函数-&gt;基于QTextDocument类 QTextFrame QTextBlock QTextTable QTextList文本块表格、列表与图片查找功能语法高亮与HTML 拖放操作使用拖放打开文件自定义拖放操作打印文档为什么后面没内容了呢？发现看电子档太无聊了啊，然后开始看视频了。。。。]]></content>
      <categories>
        <category>界面</category>
      </categories>
      <tags>
        <tag>Qt Creator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QtCreator学习（2）]]></title>
    <url>%2F2019%2F05%2F02%2FQtCreator%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[布局管理Qt主要提供了QLayout类及其子类作为布局管理器。 布局管理系统一旦一个部件上设置了布局管理器，那么它会完成以下几种任务: 定位子部件; 感知窗口默认大小;➢感知窗口最小大小; 窗口大小变化时进行处理;➢当内容改变时自动更新: 字体大小、文本或 子部件的其他内容随之改变; 隐藏或显示子部件; 移除一个子 部件。 布局管理器 QLayout类是布局管理器的基类,是一个抽象基类,継承自QObject 和QLayoutItem类, Qlayoutltem类提供了一个供Qlayout操作的抽象項目。Qlayout 和QLayoutItem都是在设计自己的布局管理器吋オ使用的,一般只需要使用QLayout的几个子类即可,它们分別是QBoxlayout(基本布局管理器)、QGridLayout(柵格布局管理器)、QFormLayout(窗体布局管理器)和QStackedlayout(桟布局管理器)。这里的;QStackedlayout与（1）中述的桟部件QStackedWidget用法相同,不再螯述。 打开Qt Creator ,新建Qt Widgets应用,项目名称为mylayout,基类选择QWidget,类名设为MyWidget。完成后打开mywidget. ui文件,在设计模式中向界面上拖入一个字体选择框Font Combo Box和一个文本编辑器Text Edit部件。然后单击主界面并按下Ctrl+L快捷键,或者单击设计器上部边栏中的 “目” 图标来对主界面进行垂直布局管理。也可以在主界面上右击，在弹出的级联菜单中选择“布局→垂直布局”。这样便设置了顶层布局管理器(因为是对整个窗口设置的布局管理器，所以叫顶层布局管理器),可以看到两个部件已经填满了整个界面。这时运行程序，然后拉伸窗口,两个部件会随着窗口的大小变化而变化,运行结果如图4所示。这就是布局管理器的作用。 基本布局管理器 基本布局管理器QBoxLayout类可以使子部件在水平方向或者垂直方向排成一列,它将所有的空间分成一行盒子，然后将每个部件放人一个盒子中。它有两个子类QHBoxLayout水平布局管理器和QVBoxLayout垂直布局管理器,编程中经常用到。再回到设计模式中看看布局管理器的属性。先单击主界面,查看它的属性栏,最后面的部分是其使用的布局管理器的属性,如下表所列。 下面打破已有的布局,使用代码实现水平布局。在界面上右击，然后在弹出的级联菜单中选择“打破布局”,或者单击设计器上方边栏中的打破布局图标。在MyWidget类的构造函数中添加如下代码: 123456789# include &lt; QHBoxLayout&gt; QHBoxLayout *layout=new QHBoxLayout; //新建布局管理器 layout-&gt;addWidget(ui-&gt;fontComboBox); //向布局管理器中添加部件 layout-&gt;addWidget(ui-&gt;textEdit); layout-&gt;setSpacing(50); //设置部件间的间隔 layout-&gt;setContentsMargins(0,0,50,100);//设置布局管理器到边界的距离 //4个参数顺序是左上右下 setLayout(layout); //将这个布局设置为MyWidget的布局 说明：除了使用addWidget()函数向布局管理器的末尾添加部件外，还可以使用insertWidget()函数向任意位置添加部件。 栅格布局管理器（QGridLayout） 栅格布局管理器QGridLayout类使部件在网格中进行布局,它将所有的空间分隔成一些行和列,行和列的交叉处形成了单元格,然后将部件放人一个确定的单元格中。先往界面上拖放一个Push Button, 然后在mywidget. cpp中添加头文件,再注释掉前面添加的关于水平布局管理器的代码,添加的如下代码:12345678# include&lt;QGridLayout&gt; QGridLayout *layout =new QGridLayout; //添加部件从0行0列开始占据一行两列 layout-&gt;addWidget(ui-&gt;fontComboBox,0,0,1,2); layout-&gt;addWidget(ui-&gt;pushButton,0,2,1,1); layout-&gt;addWidget(ui-&gt;textEdit,1,0,1,3); setLayout(layout); 窗口布局管理器（QFormLayout） 窗体布局管理器QFormLayout类用来管理表单的输人部件以及与它们相关的标签。窗体布局管理器将它的子部件分为两列,左边是一些标签,右边是一些输入部件，比如行编辑器或者数字选择框等。 先将前面在MyWidget类的构造函数中自己添加的代码全部注释掉,然后进人设计模式,这里使用另外一种方法来使用布局管理器。从部件栏中找到Form Layout,将其拖人到界面上,然后双击或者在它上面右击并在弹出级联菜单中选择“添加窗体布局行”。在弹出的“添加表单布局行”对话框中填入标签文字“姓名(&amp;N):”,这样下面便自动填写了“标签名称”、“字段类型”和“字段名称”等,并且设置了伙伴关系。这里使用了QLineEdit行编辑器,当然也可以选择其他部件。填写的标签文字中的“(&amp;N)”必须是英语半角的括号,表明它的快捷键是Alt+N。设置伙伴关系表示按下Alt+N时，光标自动跳转到标签后面对应的行编辑器中。单击“确定”键.则会在布局管理器中添加一个标签和一个行编辑器。按照这种方法,再添加3行:性别(&amp;S),使用QCo-moBox;年龄(&amp;A),使用QSpinBox;邮箱(&amp;M),使用QLineEdit。完成后运行程序，可以按下快捷键Alt+N,这样光标就可以定位到“姓名”标签后的行编辑器中。 上面添加表单行是在设计器中完成的,其实也可以在代码中使用addRow()函数来完成。 综合使用布局管理器 现在将前面的界面再进行设计:按下Ctrl键的同时选中界面上的字体选择框fontComboBox和按钮pushButton,然后按下Ctrl+H快捷键将它们放人一个水平布局管理器中(其实;也可以从部件栏中拖人一个Horizontal Layout, 然后再将这两个部件放进去，效果是:一样的)。然后再从部件栏中拖入一个Vertical Spacer垂直分隔符,用来在部件间产生间隔,将它放在窗体布局管理器与水平布局管理器之间。最后单击主界面并按下Ctrl+L快捷键,让整个界面处于一个垂直布局管理器中。这时可以在右上角的对象列表中选择分隔符Spacer,然后在属性栏中设置它的高度为100,这时运行程序可以看到,分隔符是不显示的。如图所示： 设置部件大小 讲解之前要先了解两个概念:大小提示(sizeHint)和最小大小提示(minimumSize-Hint)。凡是继承自QWidget的类都有这两个属性： sizeHint属性保存了部件的建议大小,对于不同的部件,默认拥有不同的sizeHint; minimumSizeHint保存了一个建议的最小大小提示。 可以在程序中使用sizeHint()函数来获取sizeHint的值,使用minimumSizeHint( )函数获取minimumSizeHint的值 需要说明的是，如果使用setMinimumSize()函数设置了部件的最小大小，那么最小大小提示将会被忽略。 QWidget类的属性： 大小策略(sizePolicy)属性，这个属性保存了部件的默认布局行为,在水平和垂直两个方向分别起作用,控制着部件在布局管 下面再来看一下大小策略(sizePolicy)属性,它也是QWidget类的属性。这个属性保存了部件的默认布局行为,在水平和垂直两个方向分别起作用,控制着部件在布局管理器中的大小变化行为。 sizePolicy在Qt Creator里的位置及取值： 高度与宽度属性是现在界面的大小;下面的sizePolicy属性可以设置大小策略以及伸缩因子;minimumSize属性用来设置最小值 ;maximumSize属性设置最大值; sizeIncrement属性和baseSize属性是设置窗口改变大小的，一般不用设置。 布局管理器的属性： 水平布局管理器的layoutStretch属性设置为“2,1”,这样这个水平布局管理器中的两个部件的宽度就是2:1的比例了。如果要在代码中进行设置,则可以在使用布局管理器的addWidget()函数添加部件的同时,在第二个参数中指定伸缩因子。 窗口布局管理器的属性如表所示： LayoutSizeConstraint属它是用来约束窗口大小的，也就是说,这个只对顶级布局管理器有用,因为它只对窗口有用,对其他子部件没有效果。 可扩展窗口 一个窗口可 能有很多选项是扩充的,只有在必要的时候才显示出来,这时就可以使用一个按钮来隐藏或者显示多余的内容,就是所谓的可扩展窗口。要实现可扩展窗口，就要得力于布局管理器的特性,那就是当子部件隐藏时，布局管理器自动缩小，当子部件重新显示时,布局管理器再次放大。下面看一个具体的例子。 依然在前面的程序中进行更改。首先将界面上的pushButton显示文本更改为“显示可扩展窗口”,并在其属性栏选中checkable选项。然后转到它的toggled( bool)信号的槽,更改如下: 123456void MyWidget::on_pushButton_toggled(bool checked)//隐藏窗口按钮&#123; ui-&gt;textEdit-&gt;setVisible(checked);//设置文本编辑器的扩展和隐藏true or false if(checked)ui-&gt;pushButton-&gt;setText(tr("隐藏可扩展的窗口")); else ui-&gt;pushButton-&gt;setText(tr("显示可扩展的窗口"));&#125; 这里使用按钮的按下与否两种状态来设置文本编辑器是否显示,并且相应地更改按钮的文本。为了让文本编辑器在一开始是隐藏的,还要在MyWidget类的构造函数中添加一行代码:1ui -&gt;textEdit -&gt;hide();1让文本编辑器隐藏,也可以使用setVisible( false)函数 分裂器（QSplitter） 分裂器QSplitter类提供了一个分裂器部件。和QBoxLayout类似，可以完成布局管理器的功能,但是包含在它里面的部件,默认是可以随着分裂器的大小变化而变化的。比如一个按钮放在布局管理器中,它的垂直方向默认是不会被拉伸的,但是放到分裂器中就可以被拉伸。还有一点不同就是,布局管理器继承自QObject类,而分裂器却是继承自QFrame类,QFrame类又继承自QWidget类,也就是说，分裂器拥有QWid-get类的特性,它是可见的,而且可以像QFrame一样设置边框。 新建Qt Widgets应用,项目名称为mysplitter,基类选择QWidget,类名设为MyWidget。建好项目后打开mywid-get, ui文件,然后往界面上拖人4个Push Button,同时选中这4个按钮,右击并在弹出的级联菜单中选择“布局→使用分裂器水平布局”,将这4个按钮放到一个分裂器中。将分裂器拉大点,并在属性栏中设置其frameShape为Box, frameShadow为Raised,lineWidth为5。运行程序,效果如图所示： 设置伙伴（buddy） 前面讲述窗体布局管理器时提到了设置一个标签和一个部件的伙伴关系。其实，伙伴( buddy)是在QLabel类中提出的一个概念。因为一个标签经常用作一个交互式部件的说明,就像在讲窗体布局管理器时看到的那样，一个lineEdit部件前面有一个标签说明这个lineEdit的作用。为了方便定位,QLabel提供了一个有用的机制,那就是提供了助记符来定位键盘焦点到对应的部件上,而这个部件就叫这个QLabel的伙伴。其中，助记符就是我们所说的加速键。使用英文标签时,在字符串的一一个字母前面添加“&amp;”符号,就可以指定这个标签的加速键是Alt加上这个字母;对于中文,需要在小括号中指定加速键字母,这个前面已经见过多次了。Qt设计器中也提供了伙伴设计模式,下面看一个例子。 新建Qt Widgets应用,项目名称为mybuddy,基类选择QWidget,类名设为MyWidget。完成后打开mywidget,ui文件,往界面上拖放4个标签Label, 再在标签后面依次放上PushButton、CheckBox、LineEdit和SpinBox。然后将PushButton前面的标签文本改为“&amp;Button:”, Check-Box前面的标签文本改为“C&amp;heckBox:”,LineEdit前面的标签文本改为“行编辑器(&amp;L):”, SpinBox前面的标签文本改为“数字选择框(&amp;N):”。单击设计器上方边栏中的编辑伙伴图标进入伙伴设计模式,分别将各个标签与它们后面的部件关联起来。然后按下F3键回到正常编辑模式,可以看到所有的&amp;符号都不显示了。 现在运行程序,按下Alt+ B组合键，则可以看到按钮被按下了,而字母下面多了一个横杠,表示这个标签的加速键就是Alt加这个字母。如果要在代码中设置伙伴关系，则只需要使用QLabel的setBuddy()函数就可以了。本小节内容可以在帮助索引中通过Qt Designer’s Buddy Editing Mode关键字查看。 设置Tab键顺序 对于一个应用程序,有时总希望使用Tab键将焦点从一个部件移动到下一个部件。在设计模式中,设计器提供了Tab键的设置功能。在前面程序的设计模式中,按下，上方边栏的编辑Tab顺序按钮进人编辑Tab键顺序模式,这时已经显示出了各个部件的Tab键顺序,只需要单击这些数字就可以更改顺序。设置好之后,可以运行一下程序测试效果。需要说明，当程序启动时，焦点会在Tab键顺序为1的部件上。这里进行的设置等价于在MyWidget类的构造函数中使用如下代码: 123setTabOrder(ui -&gt; lineEdit, ui -&gt;spinBox); //lineEdit 在spinBox前面 setTabOrder(ui -&gt; spinBox, ui -&gt;pushButton); // spinBox 在pushButton前面 setTabOrder(ui -&gt; pushButton, ui -&gt;checkBox); // pushButton在checkBox前面 关于在设计器中设置Tab键顺序,可以在帮助索引中通过Qt Designer’s TabOrder Editing Mode关键字查看。 Qt Creator中的定位器 定位器,它位于主界面的左下方。使用定位器可以很方便地打开指定文件、定位到文档的指定行、打开一个特定的帮助文档、进行项目中函数的查找等。更多的功能可以在帮助索引中通过Searching With the Locator关键字查看。 定位器中提供了多个过滤器来实现不同的功能,按下Ctrl+K快捷键就会在定位器中显示各个过滤器的前缀及其功能，如图所示。使用方法是“前缀符号+空格+要定位的内容”。 在Qt Creator中,按下Ctrl+K快捷键打开定位器,这时输人“18”(英文字母1和一个空格,然后是数字8),按下Enter回车键,就会跳转到编辑模式的当前打开文档的第8行。再次按下Ctrl + K快捷键,输入“? qla” ,这时已经查找到了QLabel, 按下回车键,就会跳转到帮助模式中,并打开QLabel类的帮助文档。]]></content>
      <categories>
        <category>界面</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QtCreator学习（1）]]></title>
    <url>%2F2019%2F04%2F28%2FQtCreator%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Qt是一个跨平台的c++图形用户界面应用程序框架。 窗口部件 基础窗口部件QWidget 窗口、子部件以及窗口类型QWidget类是所有用户界面对象的基类 打开Qt Creator，新建空的qmake项目,项目名为mywidget1，完成后在mywidget1.pro中添加1QT+=widgets 然后在项目中添加C++源文件main.cpp，添加以下代码：123456789101112131415161718192021222324252627282930//包含QApplication,QWidget等#include&lt;QtWidgets&gt;int main(int argc,char *argv[])&#123; QApplication a(argc,argv); //新建Qwidget类对象，默认parent参数是0，所以他是一个窗口 QWidget *widget=new QWidget(); //设置窗口标题 widget-&gt;setWindowTitle(QObject::tr("我是widget")); //新建Qlabel对象,也是一个窗口 QLabel *label=new QLabel(); label-&gt;setWindowTitle(QObject::tr("我是label")); //设置显示文本 label-&gt;setText(QObject::tr("label：我是一个窗口")); //改变部件大小，以便能显示出完整的内容 label-&gt;resize(380,200); //指定了父窗口为widget，所以不是窗口 QLabel *label2= new QLabel(widget); label2-&gt;setText(QObject::tr("label2:我不是独立窗口，只是widget的子部件")); label2-&gt;resize(450,200); //在屏幕上显示 label-&gt;show(); widget-&gt;show(); int ret =a.exec(); delete label; //QT销毁父对象时会自动销毁子对象 delete widget; return ret;&#125; 运行结果： 注意：这里使用new操作符为label2分配了空间，但是并没有使用delete进行释放，这是应为在Qt中销毁父对象的时候会自动销毁子对象，这里label2指定了parent为widget QWidget的构造函数有两个参数：1234//parent表示父窗口部件，默认为0，表示没有父窗口，后面的参数是 Qt::WindowType枚举类型//用来指定各种窗口系统属性，f=0表示窗口类型值为Qt::Widget,这种类型的部件如果有父窗口，//那么他就是子部件，否则就是独立窗口.QWidget(QWidget*parent = 0,Qt::WindowFlags f=0) 修改创建对象的两行代码为，运行程序查看效果：12QWidget *widget=new QWidget(0,Qt::Dialog);QLabel *label=new QLabel(0,Qt::SplashScreen); 再次更改：123QWidget *widget=new QWidget(0,Qt::Dialog|Qt::FramelessWindowHint);//label窗口一直在“图层”最上面QLabel *label=new QLabel(0,Qt::SplashScreen|Qt::WindowStaysOnTopHint); 说明：更多的f参数的使用,可以在帮助中索引Qt::WindowFlags关键字 窗口几何布局窗口的大小和位置，根据是否包含边框和标题栏两种情况，要用不同的函数来获取。可以在帮助索引中查看 Window and Dialog Widgets 关键字 这里的函数分为两类： 包含框架：x()、y()、frameGeometry()、pos()、move()等函数 不包含框架：geometry()、width（）、height()、rect()、size()等函数 程序调试这部分内容可以在帮助索引中通过Interacting with the Debugger 和Debugging a C++Example Application关键字查看 设置断点创建mywidght2项目，主函数内容为：12345678910111213141516#include&lt;QApplication&gt;#include&lt;QWidget&gt;int main(int argc,char *argv[])&#123; QApplication a(argc,argv); QWidget widget; int x=widget.x(); int y=widget.y(); //QRect类型返回数据为：（x,y,宽，高） QRect geometry =widget.geometry(); QRect frame =widget.frameGeometry(); return a.exec();&#125; 在一行代码前面单击来设置断点，取消再单击一下，如图： 单步调试–&gt;快捷键F11。 使用qDebug()函数更改上面的程序：1234567891011121314151617181920212223242526#include&lt;QApplication&gt;#include&lt;QWidget&gt;//使用qDebug（）函数要添加#include&lt;QDebug&gt;头文件#include&lt;QDebug&gt;int main(int argc,char *argv[])&#123; QApplication a(argc,argv); QWidget widget; widget.resize(400,300); //窗口大小 widget.move(200,100); //窗口位置 widget.show(); int x=widget.x(); qDebug("x:%d",x); int y=widget.y(); qDebug("y:%d",y); QRect geometry =widget.geometry(); QRect frame =widget.frameGeometry(); qDebug()&lt;&lt;"geometry:"&lt;&lt;geometry&lt;&lt;"frame:"&lt;&lt;frame; qDebug()&lt;&lt;"pos:"&lt;&lt;widget.pos()&lt;&lt;endl&lt;&lt;"rect:"&lt;&lt;widget.rect() &lt;&lt;endl&lt;&lt;"size:"&lt;&lt;widget.size()&lt;&lt;endl&lt;&lt;"width:"&lt;&lt;widget.width() &lt;&lt;endl&lt;&lt;"height:"&lt;&lt;widget.height(); return a.exec();&#125; 运行结果：123456789Starting D:\QT\03\3-02\build-mywidget2-Desktop_Qt_5_6_0_MinGW_32bit-Debug\debug\mywidget2.exe...x:200y:100geometry: QRect(211,145 400x300) frame: QRect(200,100 422x356)pos: QPoint(200,100) rect: QRect(0,0 400x300) size: QSize(400, 300) width: 400 height: 300 对话框QDialog模态和非模态对话框索引关键字QDialog 和Dialog Windows对话框分为两类： 模态对话框：就是在没有关闭它之前不能再与同一个应用程序的其他窗口进行交互。 非模态对话框：既可以与它交互也可以与同一程序中的其他窗口交互。 新建Qt Widgets应用，项目名称为mydialog1，基类选择QWidget,类名为MyWidget,然后在mywidget.cpp文件中添加一下代码：123456789101112#include"mywidget.h"#include"ui_mywidget.h"#include&lt;QDialog&gt;MyWidget::MyWidget(QWidget *parent): QWidget(parent), ui(new Ui::MyWidget)&#123; ui-&gt;setupUi(this); QDialog dialog(this); //父窗口为MyWidget类对象 dialog.show();&#125; 运行程序发现dialog窗口一闪而过，只显示myWidget窗口了，是因为，dialog只在mywidget这个构造函数中有用，这个构造函数执行完了，dialog也就消失了。解决办法： 非模态对话框 12QDialog *dialog =new QDialog(this); //创建一个对象，用new开辟内存空间dialog-&gt;show(); 模态 12QDialog dialog(this); dialog.exec(); 运行程序，对话框弹出来，但MyWidget窗口并没有弹出，当关闭对话框后MyWidget才弹出来 模态 123QDialog *dialog =new QDialog(this); //创建一个对象，用new开辟内存空间dialog-&gt;setModal(true);dialog-&gt;show(); 运行程序，两个对话框都显示出来，但只有在关闭对话框之后才能操作MyWidget窗口。 setModal()函数默认设置是Qt::ApplicationModal. setWindowModality()函数，它有一个参数来设置模态对话框要阻塞的窗口类型，可以是： Qt::NonModal(不阻塞任何窗口,就是非模态)、 Qt:: WindowModal(阻塞它的父窗口、所有祖先窗口以及它们的子窗ロ) Qt: ApplicationModal(阻塞整个应用程序的所有窗口)。 多窗口切换信号和槽新建Qt Widgets应用，项目名称为mydialog2，继承QWidget,双击mywidget. ui文件,在设计模式中往界面添加一个Label和一个PushButton,在属性栏中将PushButton的objectName改为showChildButton,然后更改Label 的显示文本为“我是主界面!”,更改按钮的显示文本为“显示子窗口”。然后回到编辑模式打开mywidget. h文件,在MyWidget类声明的最后添加槽的声明:一、 手动关联 定义槽 12public slots: void showChildDialog(); 到源文件中编写这个槽的实现代码 Qt Creator设计了一个快速添加定义的方法:单击showChildDialog()槽,同时按下Alt+ Enter键(也可以在函数上右击,在弹出的级联菜单中选择Refactor 菜单项),会弹出“在mywidget. cpp添加定义”选项,再次按下回车键Enter,编辑器便会转到mywidget. cpp文件中,并且自动创建showChildDialog()槽的定义,只需要在其中添加代码即可。这种方法也适用于先在源文件中添加定义,然后自动在头文件中添加声明的情况。 添加代码：12345678910111213141516171819202122232425#include "mywidget.h"#include "ui_mywidget.h"#include&lt;QDialog&gt;MyWidget::MyWidget(QWidget *parent) : QWidget(parent), ui(new Ui::MyWidget)&#123; ui-&gt;setupUi(this); //添加代码 connect(ui-&gt;showChildButton,&amp;QPushButton::clicked, this,&amp;MyWidget::showChildDialog);&#125;MyWidget::~MyWidget()&#123; delete ui;&#125;void MyWidget::showChildDialog()&#123; //添加代码 QDialog *dialog = new QDialog(this); dialog-&gt;show();&#125; 这里使用了connect( )函数将按钮的单击信号clicked() 与新建的槽进行关联。clicked( )信号在QPushButton类中定义，而connect()是QObject类中的函数,因为MyWidget类继承自QObject,所以可以直接使用它。connect()函数中的4个参数分别是发射信号的对象、发射的信号、接收信号的对象和要执行的槽。 运行程序,然后单击主界面上的按钮就会弹出一个对话框。 二、自动关联。 自动关联就是将关联函数整合到槽命名中，比如前面的槽可以重命名为on_show-ChildButton_ clicked(), 就是由字符on、发射信号的部件对象名和信号名组成。这样就可以去掉connect()关联函数了,具体做法： 打开mywidget. cpp文件,在MyWidget类的构造函数中删除connect()函数,然后更改showChildDialog()槽的名字,QtCreator中提供了一个快捷方式来更改所有该函数出现的地方,从而不再需要逐- -更改函数名。先在showChildDialog上右击，在弹出的级联菜单中选择Refactor- Rename Symbol Under Cursor,或者直接使用Ctrl+ Shift+ R快捷键,在出现的替换栏中输入on_ showChildButton_ clicked ,再单击Replace就可以了。这时源文件和头文件中相应的函数名都进行了更改。现在运行程序,和前面的效果是一样的。 源文件代码如下：12345678910111213141516171819202122#include "mywidget.h"#include "ui_mywidget.h"#include&lt;QDialog&gt;MyWidget::MyWidget(QWidget *parent) : QWidget(parent), ui(new Ui::MyWidget)&#123; ui-&gt;setupUi(this); //on_showChildButton_clicked();&#125;MyWidget::~MyWidget()&#123; delete ui;&#125;void MyWidget::on_showChildButton_clicked()&#123; QDialog *dialog = new QDialog(this); dialog-&gt;show();&#125; 自定义对话框新建Qt Widgets应用，项目名称为mydialog3，继承QWidget. 添加自定义对话类框。首先向该项目中添加Qt设计师界面类。界面模板选择Dialog without Buttons, 类名改为MyDialog。然后在设计模式中向窗口添加两个Push Button,并且分别更改其显示文本为“进入主界面”和“退出程序”。 设计信号和槽。 使用设计器来实现“退出程序”按钮的信号和槽的关联。 单击设计器上方的Edit Signals/ Slots图标,或者按下快捷键F4,于是进入了部件的信号和槽的编辑模式。在“退出程序”按钮上按住鼠标左键，然后拖动到窗口界面上,这时松开鼠标左键。在弹出的配置连接对话框中选择“显示从QWidget继承的信号和槽”选项,然后在左边的QPushButton栏中选择信号clicked(),在右边的QDialog栏中选择对应的槽close(),完成后单击OK按钮. 要想取消这个关联,只须在信号和槽编辑模式中选择这个关联;当它变为红色时,按下Delete 键,或者右击选择“删除”。也可以在设计器下方的信号和槽编辑器中看到设置好的关联。 设置好关联后按下F3键,或者单击“编辑控件”图标,则回到部件编辑模式。 关于设计器中信号和槽的详细使用,可以在帮助索引中通过QtDesigner’sSignalsandSlotsEd-iting Mode关键字查看。 现在设置“进人主界面”按钮的信号和槽的关联。 在该按钮上右击,在弹出的级联菜单中选择“转到槽”，然后在弹出的对话框中选择clicked()信号,并单击OK按钮。这时便会进人代码编辑模式,并且定位到自动生成的on_pushButton_ clicked()槽中 。在其中添加代码: 1234void MyDialog::on_pushButton_clicked()&#123; accept();&#125; 说明：这个acceptO)函数是QDialog类中的一个槽,対于一个使用exec()函数实现的模态対话框,执行了这个槽就会隠藏这个模态対活框,并返回QDialog::Accepted值，这里里就是要使用这个值来判断是哪个按钮被按下了。与其对应的还有一个reject()槽，它可以返回一个QDialog::Rejected值,前面的“退出程序”按钮也可以关联这个槽。 在主界面中使用自定义的对话框 更改main.cpp函数内容如下 12345678910111213141516#include "mywidget.h"#include &lt;QApplication&gt;#include"mydialog.h"int main(int argc, char *argv[])&#123; QApplication a(argc, argv); MyWidget w; MyDialog dialog; if(dialog.exec()==QDialog::Accepted)&#123; //判断dialog执行结果 w.show(); //如果按下了“进入主界面”按钮，则显示主页面 return a.exec(); &#125; else return 0;&#125; 主函数中建立MyDialog对象,然后判断其exec()函数的返回值,如果按下了“进人主界面”按钮,返回值应该是QDialog:: Accepted,则显示主界面,并且正常执行程序;如果不是,则直接退出程序。 运行程序后可以发现,已经实现了从登录对话框到主界面,再从主界面显示一个对话框的应用了。再来实现可以从主界面重新进入登录界面的功能。双击mywidget. ui文件,在设计模式中再向界面添加两个Push Button,分别更改它们的显示文本为“重新登录”和“退出”。然后使用信号和槽模式将“退出”按钮的clicked()信号和MyWidget界面的close()槽关联。完成后再转到“重新登录”按钮的clicked()信号的槽，并更,改如下: 1234567891011void MyWidget::on_pushButton_clicked()&#123; //先关闭主界面，其实它是隐藏起来了，并没有退出 close(); //新建MyDialog对象 MyDialog dlg; //如果按下了“进入主窗口“按钮，则再次显示主界面 //否则，因为现在已经没有显示的界面了，所以程序将退出 if(dlg.exec()==QDialog::Accepted) show();&#125; 说明：那个close()槽,它不一定使程序退出，只有当只剩下最后一个主界面了(就是没有父窗口的界面),这时调用close()槽,程序才会退出;而其他情况下界面只是隐藏起来了,并没有被销毁。这里还需要包含MyDialog类的头文件#include“mydialog. h” ,然后运行程序查看效果。 标准对话框新建Qt Widgets应用，项目名称为mydialog5，继承QWidget.本节帮助索引Standard Dialogs关键字。添加如图所示按钮： 颜色对话框 在mywidget.cpp文件中添加： 12#include&lt;QDebug&gt;#include&lt;QColorDialog&gt; 进入“颜色对话框”按钮的clicked()信号槽，用静态函数直接直接显示颜色对话框： 12345678void MyWidget::on_pushButton_clicked()&#123;//参数分别是：设置初始颜色、指定父窗口、设置对话框标题 QColor color = QColorDialog::getColor(Qt::red,this,tr("颜色对话框")); //,QColorDialog::ShowAlphaChannel); //添加透明度选项 1.0表示完全不透明，0.0表示完全透明 qDebug()&lt;&lt;"color:"&lt;&lt;color;&#125; 或者，创建一个对象： 123456789void MyWidget::on_pushButton_clicked()&#123; QColorDialog dialog(Qt::red,this); dialog.setOption(QColorDialog::ShowAlphaChannel);//显示透明度选项 //1.0表示完全不透明，0.0表示完全透明 dialog.exec(); //模态方式运行对话框 QColor color = dialog.currentColor(); //获取当前颜色 qDebug()&lt;&lt;"color:"&lt;&lt;color;&#125; 运行结果： 文件对话框12345678910111213void MyWidget::on_pushButton_2_clicked()&#123; //参数分别是：指定父窗口、设置对话框标题、默认打开目录路径和设置文件类型过滤器 //如果不指定过滤器则默认选择所有类型文件 //同文件类型不同格式要用空格隔开，不同类型用“;;”隔开。// QString fileName=QFileDialog::getOpenFileName(this,tr("文件对话框"),// "D:",tr("图片文件(*png *jpg);;文本文件(*txt)"));// qDebug()&lt;&lt;"fileName:"&lt;&lt;fileName;//同时选择多个文件 QStringList fileNames=QFileDialog::getOpenFileNames(this,tr("文件对话框"), "D:",tr("图片文件(*png *jpg)")); qDebug()&lt;&lt;"fileNames:"&lt;&lt;fileNames;&#125; 其他函数： getSaveFileName()实现保存文件对话框和文件另存对话框 getExistingDirectory()获取一个已存在的文件夹路径 运行结果： 字体对话框12345678void MyWidget::on_pushButton_3_clicked()&#123; //ok用于标记是否单击了ok按钮 bool ok; QFont font =QFontDialog::getFont(&amp;ok,this); if(ok) ui-&gt;pushButton_3-&gt;setFont(font); else qDebug()&lt;&lt;tr("没有选择字体！");&#125; 运行结果： 输入对话框12345678910111213141516171819202122232425262728void MyWidget::on_pushButton_4_clicked()&#123; bool ok; //指定父窗口、设置窗口标题、设置对话框中的标签显示文本、设置输入字符串的 //显示模式(例如密码可以显示成小黑点,这里选择了显示用户输人的实际内容)、 //设置输入框中的默认字符串和设置获取按下按钮信息的bool变量; QString string =QInputDialog::getText(this,tr("输入字符串对话框"), tr("请输入用户名："),QLineEdit::Normal,tr("admin"),&amp;ok); if(ok)qDebug()&lt;&lt;"string:"&lt;&lt;string; //其中的参数100表示默认的数值是100,一1000表示可输人的最小值是一1 000, //1000表示可输人的最大值是1000,10表示使用箭头按钮,数值每次变化10 int value1=QInputDialog::getInt(this,tr("输入整数对话框"), tr("请输入-1000到1000之间的数值"),100,-1000,1000,10,&amp;ok); if(ok)qDebug()&lt;&lt;"value1:"&lt;&lt;value1; //参数2表示小数的位数为2 double value2=QInputDialog::getDouble(this,tr("输入浮点数对话框"), tr("请输入-1000到1000之间的数值"),0.00,-1000,1000,2,&amp;ok); if(ok)qDebug()&lt;&lt;"value2:"&lt;&lt;value2; //参数0表示默认显示列表中的第0个条目(0就是第一个),参数true设置条目是否可以被更改.true就是可以被更改。 QStringList items; items&lt;&lt;tr("条目1")&lt;&lt;tr("条目2"); QString item=QInputDialog::getItem(this,tr("输入条目对话框"), tr("请选择或输入一个条目"),items,0,true,&amp;ok); if(ok)qDebug()&lt;&lt;"item:"&lt;&lt;item;&#125; 消息对话框123456789101112131415161718192021222324void MyWidget::on_pushButton_5_clicked()&#123; //分别拥有不同的图标和提示音 //参数：父窗口、标题栏、显示信息、拥有的按钮 int ret1=QMessageBox::question(this,tr("问题对话框"), tr("你了解Qt吗？"),QMessageBox::Yes,QMessageBox::No); if(ret1==QMessageBox::Yes)qDebug()&lt;&lt;tr("问题！"); int ret2=QMessageBox::information(this,tr("提示对话框"), tr("这是Qt书籍！"),QMessageBox::Ok); if(ret2==QMessageBox::Ok)qDebug()&lt;&lt;tr("提示！"); int ret3=QMessageBox::warning(this,tr("警告对话框"), tr("不能提前结束？"),QMessageBox::Abort); if(ret3==QMessageBox::Abort)qDebug()&lt;&lt;tr("警告！"); int ret4=QMessageBox::critical(this,tr("严重错误对话框"), tr("发现一个严重错误！现在要关闭所有文件！"),QMessageBox::YesAll); if(ret4==QMessageBox::YesAll)qDebug()&lt;&lt;tr("错误！"); QMessageBox::about(this,tr("关于对话框"), tr("Qt及QtCreator")); QMessageBox::aboutQt(this,tr("关于qt"));&#125; 进度条对话框123456789101112131415void MyWidget::on_pushButton_6_clicked()&#123; //参数：设置对话框的标签内容、取消按钮的显示文本、最小值、最大值和和父窗口 QProgressDialog dialog(tr("文件复制进度"),tr("取消"),0,50000,this); dialog.setWindowTitle(tr("进度对话框")); dialog.setWindowModality(Qt::WindowModal); //将对话框设置为模态 dialog.show(); for(int i=0;i&lt;50000;i++)&#123; //演示进度条 dialog.setValue(i); //设置进度条当前值 QCoreApplication::processEvents(); //避免界面冻结 if(dialog.wasCanceled())break; //按下取消按钮则中断 &#125; dialog.setValue(50000); //这样才能显示100%,因为for循环中少加一个数 qDebug()&lt;&lt;tr("复制结束！");&#125; 错误信息对话框在mywidget.h文件中 添加类前置声明 1class QErrorMessage; 添加私有对象： 1QErrorMessage *errordlg 在mywidget.cpp中 在构造函数中添加： 1errordlg = new QErrorMessage(this); 添加槽信号 12345void MyWidget::on_pushButton_7_clicked()&#123; errordlg-&gt;setWindowTitle(tr("错误信息对话框")); errordlg-&gt;showMessage(tr("这里是出错信息！"));&#125; 向导对话框在mywidget.h文件中 添加头文件 1#include&lt;QWizard&gt; 在MyWidget类中添加private类型函数声明 1234567private: Ui::MyWidget *ui; QErrorMessage *errordlg; QWizardPage *createPage1(); QWizardPage *createPage2(); QWizardPage *createPage3();&#125;; 在mywidget.cpp中添加：123456789101112131415161718192021222324252627QWizardPage *MyWidget::createPage1()&#123; QWizardPage *page =new QWizardPage; page-&gt;setTitle(tr("介绍")); return page;&#125;QWizardPage *MyWidget::createPage2()&#123; QWizardPage *page =new QWizardPage; page-&gt;setTitle(tr("用户选择信息")); return page;&#125;QWizardPage *MyWidget::createPage3()&#123; QWizardPage *page =new QWizardPage; page-&gt;setTitle(tr("结束")); return page;&#125;//右击设置槽函数void MyWidget::on_pushButton_8_clicked()&#123; QWizard wizard(this); wizard.setWindowTitle(tr("向导对话框")); wizard.addPage(createPage1()); wizard.addPage(createPage2()); wizard.addPage(createPage3()); wizard.exec();&#125; 运行结果： 其他窗口部件QFrame类 QFrame类是带有边框的部件的基类。它的子类包括最常用的标签部件QLabel,另外还有QLCDNumber、QSplitter、QStackedWidget, QToolBox和QAbstractScrol-lArea类。QAbstractScrollArea类是所有带有滚动区域的部件类的抽象基类,这里需要说明,Qt中凡是带有Abstract 字样的类都是抽象基类。抽象基类是不能直接使用的,但是可以继承该类实现自己的类,或者使用它提供的子类。 QFrame边框形状和阴影 新建Qt Widgets应用，项目名称为mydialog5，继承QWidget.在Qt设计器中从部件列表里拖入一个Frame到界面上,然后在右下方的属性栏中更改其frameShape为Box, frameShadow为Sunken , lineWidth为5,midLineWidth为10。在属性栏中设置部件的属性,这和在源码中用代码实现是等效的,其实也可以直接在mywidget.cpp文件中的MyWidget构造函数里使用代码。 QLabel 标签QLabel部件用来显示文本或者图片。在设计器中向界面拖人一个Label,然后将其拖大点，并在属性栏中设置对其方式alignment的属性,水平的改为AlignH-Center ,垂直的改为AlignVCenter,这样QLabel中的文本就会在正中间显示。font 属性可以对字体进行设置,也可以通过代码进行设置,下面打开mywidget. cpp文件,在构造函数中添加如下代码: 1234567//设置字体样式 QFont font; font.setFamily("华文行楷"); font.setPointSize(20); font.setBold(true); font.setItalic(true); ui-&gt;label-&gt;setFont(font); QLabel属性栏中的wordWrap属性可以实现文本的自动换行。QFontMetrics类实现自动省略 继续在构造函数例添加代码：12345//实现文本自动换行 QString string = tr("标题太长，需要进行省略！"); //参数分别是：要省略的文本、省略的模式（就是省略号出现的位置）、文本的长度 QString str=ui-&gt;label-&gt;fontMetrics().elidedText(string,Qt::ElideRight,180); ui-&gt;label-&gt;setText(str); 显示图片：12345678910 #include&lt;QPixmap&gt; //标签中添加图片，设计器中scaledContents属性选中可以显示整个图片 ui-&gt;label-&gt;setPixmap(QPixmap("D:/QT/pig.jpg")); #include&lt;QMovie&gt; //显示GIF动态图片 QMovie *movie=new QMovie("D:/A/img/cat.gif"); ui-&gt;label-&gt;setMovie(movie); movie-&gt;start();&#125; QLCDNumber QLCDNumber部件可以让数码字符显示类似液晶数字一样的效果。从部件栏中拖入一个LCD Number部件到界面上，然后更改其属性: 选中smallDecimalPoint项，这样可以显示小数点; digitCount的作用是设置显示的数字的个数,设置为7,表示要显示7个数字; mode选Dec表示显示十进制数值,这里还可以设置显示为十六进制(Hex)、八进制(Oct)和二进制( Bin)数值; segmentStyle用来设置数码的显示样式,这里提供了3种样式,选择Filled; value设置为456. 123,这就是要显示的数值; 也可以在代码中使用display()函数来设置要显示的数值。 在QLCDNumber中可以显示的数码有0/O.1.2.3.4.5/S.6.7.8.9/g、负号、小数点、A、B、C、D、E、F、h、H、L、o、P、r、u、U、Y、冒号、度符号(输人时使用单引号来代替)和空格。 QStackedWidget QStackedWidget类提供了- -个部件栈,可以有多个界面(称为页面),每个界面可以拥有自己的部件,不过每次只能显示一个界面。这个部件需要使用QComboBox或者QListWidget来选择它的各个页面。 在设计模式中向界面上拖入一个List Widget和一个StackedWidget。 在ListWidget.上右击,在弹出的级联菜单中选择“编辑项目”项,然后在“编辑列表窗口部件”对话框中按下左下角的加号添加两项,并更该名称为“第一页”和“第二页”。 然后在Stacked Widget 上拖人一个Label,更改文本为“第一页”,再单击Stacked Widget右上角的小箭头进入下一页,再拖入一个标签,更改文本为“第二页”。 然后再将Stacked Widget 部件的frameShape属性更改为StyledPanel。 最后，在信号和槽设计模式将listWidget 部件的currentRowChanged( )信号和stackedWidget的setCurrentIndex()槽关联。 设置完成后运行程序可以看到，现在可以单击listWidget中的项目来选择stackedWidget的页面了。 QToolBox QToolBox类提供了一.列层叠窗口部件,就像常用的聊天工具QQ中的抽屉效果。 从部件栏中选择ToolBox拖人到界面上,右击并在弹出的级联菜单中选择“插人页→在当前页之后”项来新插入一页。 然后更改其frameShape属性为Box,更改currentIndex即为第几个”抽屉“,更改其对应cucurrenttItemText分别为“好友”、“黑名单”、“陌生人”、“特别讨厌”、”特别关心“。 最后所有的运行结果如图所示： ) 按钮部件 QAbstractButton类是按钮部件的抽象基类，提供了按钮的通用功能。它的子类包括复选框QCheckBox、标准按钮QPushButton.单选框按钮QRadioButton和工具按钮QToolButton。 新建Qt Widgets应用,项目名称mybutton,基类选择QWidget,类名设为MyWidget。完成后在项目文件夹中新建images文件夹,并且放人几张图标图片,供下面编写程序时使用。 QPushButton QPushButton提供- - 个标准按钮。在项目中打开mywidget. ui文件,拖人3个PushButton到界面上.然后将它们的objectName依次更改为pushBtnl、pushBtn2和pushBtn3。下面选中pushBtnl的checkable属性,使得它可以拥有“选中”和“未选中”两种状态;再选中pushBtn2的flat 属性,可以不显示该按钮的边框。然后转到push-Btnl的toggled( bool)信号的槽.更改如下:123456#include&lt;QDebug&gt;void MyWidget::on_pushBtn1_toggled(bool checked)//按钮是否处于被按下状态&#123; qDebug()&lt;&lt;tr("按钮是否按下：")&lt;&lt;checked;//按下checked为true,否则为false&#125; 在MyWidget的构造函数里添加代码： 12345678910include&lt;QMenu&gt; ui-&gt;pushBtn1-&gt;setText(tr("&amp;nihao")); //Alt+n为加速键 ui-&gt;pushBtn2-&gt;setText(tr("帮助(&amp;H)")); //给按钮添加图标 ui-&gt;pushBtn2-&gt;setIcon(QIcon("D:/QT/03/3-07/mybutton/images/loading7.png")); ui-&gt;pushBtn3-&gt;setText(tr("z&amp;oom")); QMenu *menu =new QMenu(this); menu-&gt;addAction(QIcon("D:/QT/03/3-07/mybutton/images/selected.png"),tr("放大")); ui-&gt;pushBtn3-&gt;setMenu(menu); QcheckBox、QRadioButton和QGroupBox 对于调查表之类的应用,往往提供多个选项供选择,有些是可以选择多项的,有些只能选择其中-一项。复选框QCheckBox类提供了同时选择多项的功能,而QRadioButton提供了只能选择- -项的功能，一般要把-一组按钮放到一个QGroupBox中来管理。 在设计模式时可往界面上拖人两个Group Box,将它们的标题分别改为“复选框”和“单选框”。然后往复选框中拖人3个Check Box,分别更改显示内容为“跑步”、“踢球”和“游泳”。再往单选框中拖入3个Radio Button,分别更改其显示内容为“很好”、“一般”和“不好”。这里还可以选中CheckBox的tristate属性,让它拥有不改变状态、选中状态和未选中状态3种状态。对于选择按钮后的操作，可以关联它们的state-Changed(&gt;信号和自定义的槽,也可以使用isChecked()函数查看一个按钮是否被选中。除了Group Box,还可以使用QButtonGroup类来管理多个按钮。 运行结果： QLineEdit 行编辑器QLineEdit部件是-一个单行的文本编辑器，它允许用户输入和编辑单行的纯文本内容,而且提供了一系列有用的功能，包括撤销与恢复、剪切和拖放等操作。 新建Qt Widgets应用,项目名称mylineedit,基类QWidget,类名MyWidget。在设计模式时可往界面上拖人几个标签和Line Edit,设计界面运行结果所示。然后将4个Line Edit从上到下依次更改其objectName为lineEdit1 JlineEdit2 . lineEdit3和lineEdit4。 显示模式 行编辑器QLineEdit有4种显示模式(echoMode),可以在echoMode属性中更改它们，分别是: Normal正常显示输人的信息;NoEcho不显示任何输人，这样可以保证不泄露输人的字符位数; Password显示为密码样式,就是以小黑点或星号之类的字符代替输人的字符; PasswordEchoOnEdit在编辑时显示正常字符，其他情况下显示为密码样式。 这里设置lineEdit1的echoMode为Password. 输入掩码 QLineEdit提供了输人掩码( inputMask)来限制输入的内容。可以使用一些特殊的字符来设置输入的格式和内容.这些字符中有的起限制作用且必须要输入一一个字符，有的只是起限制作用,但可以不输人字符而是以空格代替。先来看一下这些特殊字符的含义,如下表所列。 下面将lineEdit2 的inputMask属性设置为“&gt; AA-90-bb-! aa# H; “,其含义为: “&gt;”号表明后面输人的字母自动转为大写; “AA”表明开始必须输人两个字母,因为有前面的“&gt;”号的作用,所以输人的这两个字母会自动变为大写; “一”号为分隔符，;直接显示,该位不可输入; “9”表示必须输人一个数字;“0”表示输入一个数字,或者留;空; “bb”表示这两位可以留空,或者输人两个二进制字符,即0或1; “!”表明停止大小写转换，就是在最开始的“&gt;”号不再起作用; “aa”表示可以留空,或者输人两个字母; “#”表示将“#”号作为分隔符,因为“#”号在这里有特殊含义,所以前面要加上“\”号; “H”表明必须输入一个十六进制的字符; “; ”表示用 “ ”号来填充空格。 另外,也可以使用setInputMask()函数在代码中来设置输人掩码。 在lineEdit2上右击,然后转到它的returnPressed()回车键按下信号的槽中。更改代码如下： 123456void MyWidget::on_lineEdit2_returnPressed() //回车键按下信号的槽&#123; ui-&gt;lineEdit3-&gt;setFocus(); //让lineEdit3获得焦点 qDebug()&lt;&lt;ui-&gt;lineEdit2-&gt;text(); //输入lineEdit2的内容 qDebug()&lt;&lt;ui-&gt;lineEdit2-&gt;displayText(); //输出lineEdit2显示的内容&#125; 输入验证 在QLineEdit中可以使用验证器（validator）来对输入进行约束在mywidget.cpp的构造函数里添加代码：1234//新建验证器，指定范围为100~999 QValidator *validator=new QIntValidator(100,999,this); //在行编辑器中使用验证器 ui-&gt;lineEdit3-&gt;setValidator(validator); 在代码中为lineEdit3添加了验证器,那么它现在只能输人100~999之间的数字。再进人lineEdit3的回车键按下信号的槽,输出lineEdit3 的内容。然后运行程序会发现,其他的字符无法输入，而输人小于100的数字时,按下回车键也是没有效果的。QValidator中还提供了QDoubleValidator,可以用它来设置浮点数。如果想设置更强大的字符约束.就要使用正则表达式了 自动补全 QLineEdit提供强大的自动补全功能通过QCompleter类实现在mywidget.cpp的构造函数里添加代码：12345678#include&lt;QCompleter&gt; QStringList wordList; //在行编辑器里输入“Q"，自动出现"QT"和”QT Creator“两个选项 wordList&lt;&lt;"QT"&lt;&lt;"QT Creator"&lt;&lt;tr("你好"); QCompleter *completer=new QCompleter(wordList,this); //新建自动完成器 completer-&gt;setCaseSensitivity(Qt::CaseInsensitive); //设置大小写不敏感 ui-&gt;lineEdit4-&gt;setCompleter(completer); 运行结果： 12345Debugging starts&quot;AB-12-01- ac#d&quot;&quot;AB-12-01- ac#d&quot;&quot;123&quot;&quot;123&quot; QAbstractSpinBox QAbstractSpinBox类是-一个抽象基类,提供了一个数值设定框和- 个行编辑器来显示设定值。它有3个子类QDate TimeEdit、QSpinBox和QDoubleSpinBox,分别用来完成日期时间、整数和浮点数的设定。 新建Qt Widgets 应用,项目名称myspinbox,基类为QWidget,类名MyWidget。 QDateTimeEdit QDateTimeEdit类提供了一个可以编辑日期和时间的部件。到设计模式,从部件栏中分别拖TimeEdit.DateEdit和Date/TimeEdit到界面上,然后设置timeEdit的;displayFormat为“h:mm:ssA” ,这就可以使用12 h制来进行显示。对于dateEdit, 选中它的calendarPopup属性,就可以使用弹出的日历部件来设置日期。然后在MyWid-get类的构造函数中添加代码:1234//设置时间为现在的系统时间 ui-&gt;dateEdit-&gt;setDateTime(QDateTime::currentDateTime()); //设置时间的显示格式 ui-&gt;dateTimeEdit-&gt;setDisplayFormat(tr("yyyy年MM月dd日dddHH时mm分ss秒")); 这里使用代码设置了dateTimeEdit中的日期和时间。简单说明一下:y表示年;M表示月;d表示日;而ddd表示星期;H表示小时,使用24 h制显示,而h也表示小时，如果最后有AM或者PM的,则是12 h制显示,否则使用24 h制;m表示分;s表示秒;还有一个z可以用来表示毫秒。更多的格式可以参考QDateTime类。现在运行程序查看效果。还要说明，可以使用该部件的text()函数获取设置的值,它返回QString类型的字符串;也可以使用dateTime()函数,它返回的是QDateTime类型数据。 QSpinBox 和QDoubleSpinBox QSpinBox用来设置整数, QDoubleSpinBox用来设置浮点数。从部件栏中找到Spin Box和Double Spin Box,并将它们拖入到界面上。可以在属性栏中看到spinBox的属性有:后缀suffix属性,可以设置为“%” ,这样就可以显示百分数了;前缀prefix属性,比如表示金钱时前面有“￥”字符;最小值minimum属性,设置其最小值;最大值maximum属性设置其最大值;单步值singleStep属性设置每次增加的数值,默认为l;value 为现在显示的数值。而doubleSpinBox又增加了一个小数位数decimals属性,用来设置小数点后面的位数。可以在代码中使用value()函数来获取设置的数值。 运行结果： QAbstractSlider QAbstractSlider类用于提供区间内的一个整数值,它有一个滑块,可以定位到一个整数区间的任意值。该类是一个抽象基类,它有3个子类QSerollBar、QSlider和QDial。其中，滚动条QScrollBar多数是用在QScrollArea类中来实现滚动区域;QSllider就是常见的音量控制或多媒体播放进度等滑块部件;QDial是-一个刻度表盘部件。 新建Qt Widgets应用,项目名称myslider,基类选择QWidget,类名为MyWidget。完成后到设计模式,从部件栏中分别将Dial、Horizontal Scroll Bar和Vertical Scroll Bar、 Horizontal Slider以及Vertical Slider 等部件拖人到界面上。 先看两个ScrollBar的属性: maximum属性用来设置最大值,minimum属性用来设置最小值; singleStep属性是每步的步长,默认是1,就是按下方向键后其数值增加或者减少1; pageStep是每页的步长,默认是10,就是按下PageUp或者PageDown按键后,其数值增加或者减少10; value与sliderPosition是当前值; tracking设置是否跟踪,.默认为是,就是在拖动滑块时,每移动一个刻度,都会发射valueChanged()信号，如果选择否,则只有拖动滑块释放时才发射该信号; orientation设置部件的方向,有水平和垂直两种选择; invertedAppearance属性设置滑块所在的位置,比如默认滑块开始在最左端，选中这个属性后,滑块默认就会在最右端。 invertedControls设置反向控制,比如默认是向上方向键是增大,向下方向键是减小,如果选中这个属性,那么控制就会正好反过来。 另外,为了使部件可以获得焦点,需要将focusPolicy设置为StrongFocus。 再来看两个Slider 它们有了自己的两个属性tickPosition和tickInterval,前者用来设置显示刻度的位置,默认是不显示刻度;后者是设置刻度的间隔。 而Dial有自己的属性wrapping,用来设置是否首尾相连,默认开始与结束是分开的; 属性notchTarget用来设置刻度之间的间隔; 属性notchesVisible用来设置是否显示刻度。 再往界面上拖人一个SpinBox,然后进人信号和槽编辑界面,将刻度表盘部件dial的sliderMoved(int)信号分别与其他各个部件的setValue(int)槽相连接。设置完成后运行程序，然后使用鼠标拖动刻度盘部件的滑块,可以看到其他所有的部件都跟着变化了。 运行结果：]]></content>
      <categories>
        <category>界面</category>
      </categories>
      <tags>
        <tag>Qt Creator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_MySQL数据库]]></title>
    <url>%2F2019%2F04%2F17%2FPython-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[MySQLMySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。 安装 安装教程查看链接Windows 上安装 MySQL MySQL常用命令以管理员身份打开cmd命令行工具，切换到你安装的mysql目录，这里是： 1D:\Mysql\mysql-8.0.15-winx64\bin 启动： 1net start mysql 登录 1mysql -h 主机名 -u 用户名 -p 如果是登录本机MySQL数据库，只需要输入以下命令：1mysql -u root -p 接下来会让你输入登录密码：输入即可，如图所示： 参数说明·： -h : 指定客户端所要登录的 MySQL 主机名(IP), 登录本机(localhost 或 127.0.0.1)该参数可以省略; -u : 登录的用户名; -p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。 退出和停止 123quit;//或者 exit...net stop mysql 修改密码 1mysqladmin -u用户名 -p旧密码 password 新密码 创建数据库 1create database &lt;数据库名&gt;; 显示数据库 1show databases; 注意：最后有个s 删除数据库 1drop database &lt;数据库名&gt; 如图所示： 更多常用命令访问：MySQL常用命令大全 mysql-connector使用 mysql-connector 来连接使用 MySQL， mysql-connector 是 MySQL 官方提供的驱动器。 安装我们可以使用 pip 命令来安装 mysql-connector：1python -m pip install mysql-connector 或者直接在pycharm的setting里面安装mysql-connect包 操作创建数据库连接123456789import mysql.connector mydb = mysql.connector.connect( host="localhost", # 数据库主机地址 user="username", # 数据库用户名 passwd="password" # 数据库密码) print(mydb) 创建数据库创建数据库使用 “CREATE DATABASE” 语句，我们创建一个名为 first_db 的数据库： 1234567891011import mysql.connector mydb = mysql.connector.connect( host="localhost", user="root", passwd="123456") mycursor = mydb.cursor() mycursor.execute("CREATE DATABASE first_db") 查看数据库输出所有数据库列表：1234567891011121314import mysql.connector mydb = mysql.connector.connect( host="localhost", user="root", passwd="123456") mycursor = mydb.cursor() mycursor.execute("SHOW DATABASES") for x in mycursor: print(x) 我们可以直接连接数据库，如果数据库不存在，会输出错误信息： 12345678import mysql.connector mydb = mysql.connector.connect( host="localhost", user="root", passwd="123456", database="runoob_db") 创建数据表1234567891011import mysql.connector mydb = mysql.connector.connect( host="localhost", user="root", passwd="123456", database="first_db" # 确保数据库first_db已存在)mycursor = mydb.cursor() mycursor.execute("CREATE TABLE sites (name VARCHAR(255), url VARCHAR(255))") 查看数据表是否已存在：1234567891011121314import mysql.connector mydb = mysql.connector.connect( host="localhost", user="root", passwd="123456", database="first_db")mycursor = mydb.cursor() mycursor.execute("SHOW TABLES") for x in mycursor: print(x) 主键设置创建表的时候我们一般都会设置一个主键（PRIMARY KEY）,主键起始值为 1，逐步递增。 如果我们的表已经创建，我们需要使用 ALTER TABLE 来给表添加主键： 12345678910111213给 sites 表添加主键。import mysql.connector mydb = mysql.connector.connect( host="localhost", user="root", passwd="123456", database="first_db")mycursor = mydb.cursor() mycursor.execute("ALTER TABLE sites ADD COLUMN id INT AUTO_INCREMENT PRIMARY KEY") 如果你还未创建 sites 表，可以直接使用以下代码创建。 给表创建主键。123456789101112import mysql.connector mydb = mysql.connector.connect( host="localhost", user="root", passwd="123456", database="first_db")mycursor = mydb.cursor() mycursor.execute("CREATE TABLE sites (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255), url VARCHAR(255))") 插入数据 向 sites 表插入一条记录。 1234567891011121314151617import mysql.connector mydb = mysql.connector.connect( host="localhost", user="root", passwd="123456", database="first_db")mycursor = mydb.cursor() sql = "INSERT INTO sites (name, url) VALUES (%s, %s)"val = ("RUNOOB", "https://www.runoob.com")mycursor.execute(sql, val) mydb.commit() # 数据表内容有更新，必须使用到该语句 print(mycursor.rowcount, "记录插入成功。") 执行代码，输出结果为：11 记录插入成功 批量插入批量插入使用 executemany() 方法，该方法的第二个参数是一个元组列表，包含了我们要插入的数据： 向 sites 表插入多条记录。1234567891011121314151617181920212223import mysql.connector mydb = mysql.connector.connect( host="localhost", user="root", passwd="123456", database="first_db")mycursor = mydb.cursor() sql = "INSERT INTO sites (name, url) VALUES (%s, %s)"val = [ ('Google', 'https://www.google.com'), ('Github', 'https://www.github.com'), ('Taobao', 'https://www.taobao.com'), ('stackoverflow', 'https://www.stackoverflow.com/')] mycursor.executemany(sql, val) mydb.commit() # 数据表内容有更新，必须使用到该语句 print(mycursor.rowcount, "记录插入成功。") 执行代码，输出结果为：124 记录插入成功。` 如果我们想在数据记录插入后，获取该记录的 ID ，可以使用以下代码：12345678 sql = "INSERT INTO sites (name, url) VALUES (%s, %s)"val = ("Zhihu", "https://www.zhihu.com")mycursor.execute(sql, val) mydb.commit() print("1 条记录已插入, ID:", mycursor.lastrowid) 执行代码，输出结果为：11 条记录已插入, ID: 6 查询数据 查询所有数据123456mycursor.execute("SELECT * FROM sites") myresult = mycursor.fetchall() # fetchall() 获取所有记录 for x in myresult: print(x) 执行代码，输出结果为：123456(1, &apos;RUNOOB&apos;, &apos;https://www.runoob.com&apos;)(2, &apos;Google&apos;, &apos;https://www.google.com&apos;)(3, &apos;Github&apos;, &apos;https://www.github.com&apos;)(4, &apos;Taobao&apos;, &apos;https://www.taobao.com&apos;)(5, &apos;stackoverflow&apos;, &apos;https://www.stackoverflow.com/&apos;)(6, &apos;Zhihu&apos;, &apos;https://www.zhihu.com&apos;) 也可以读取指定的字段数据：123456mycursor.execute("SELECT name, url FROM sites") myresult = mycursor.fetchall() for x in myresult: print(x) 执行代码，输出结果为：123456(&apos;RUNOOB&apos;, &apos;https://www.runoob.com&apos;)(&apos;Google&apos;, &apos;https://www.google.com&apos;)(&apos;Github&apos;, &apos;https://www.github.com&apos;)(&apos;Taobao&apos;, &apos;https://www.taobao.com&apos;)(&apos;stackoverflow&apos;, &apos;https://www.stackoverflow.com/&apos;)(&apos;Zhihu&apos;, &apos;https://www.zhihu.com&apos;) 如果我们只想读取一条数据，可以使用 fetchone() 方法：12345mycursor.execute("SELECT * FROM sites") myresult = mycursor.fetchone() print(myresult) 执行代码，输出结果为：1(1, &apos;RUNOOB&apos;, &apos;https://www.runoob.com&apos;) 如果我们要读取指定条件的数据，可以使用 where 语句：12345678sql = "SELECT * FROM sites WHERE name ='RUNOOB'" mycursor.execute(sql) myresult = mycursor.fetchall() for x in myresult: print(x) 执行代码，输出结果为：1(1, &apos;RUNOOB&apos;, &apos;https://www.runoob.com&apos;) 也可以使用通配符 %：12345678sql = "SELECT * FROM sites WHERE url LIKE '%oo%'" mycursor.execute(sql) myresult = mycursor.fetchall() for x in myresult: print(x) 执行代码，输出结果为：12(1, &apos;RUNOOB&apos;, &apos;https://www.runoob.com&apos;)(2, &apos;Google&apos;, &apos;https://www.google.com&apos;) 为了防止数据库查询发生 SQL 注入的攻击，我们可以使用 %s 占位符来转义查询的条件： 123456789sql = "SELECT * FROM sites WHERE name = %s"na = ("RUNOOB", ) mycursor.execute(sql, na) myresult = mycursor.fetchall() for x in myresult: print(x) 排序查询结果排序可以使用 ORDER BY 语句，默认的排序方式为升序，关键字为 ASC，如果要设置降序排序，可以设置关键字 DESC。 按 name 字段字母的升序排序：12345678sql = "SELECT * FROM sites ORDER BY name" mycursor.execute(sql) myresult = mycursor.fetchall() for x in myresult: print(x) 执行代码，输出结果为：123456(3, &apos;Github&apos;, &apos;https://www.github.com&apos;)(2, &apos;Google&apos;, &apos;https://www.google.com&apos;)(1, &apos;RUNOOB&apos;, &apos;https://www.runoob.com&apos;)(5, &apos;stackoverflow&apos;, &apos;https://www.stackoverflow.com/&apos;)(4, &apos;Taobao&apos;, &apos;https://www.taobao.com&apos;)(6, &apos;Zhihu&apos;, &apos;https://www.zhihu.com&apos;) 降序排序实例：12345678sql = "SELECT * FROM sites ORDER BY name DESC" mycursor.execute(sql) myresult = mycursor.fetchall() for x in myresult: print(x) 执行代码，输出结果为： 123456(6, &apos;Zhihu&apos;, &apos;https://www.zhihu.com&apos;)(4, &apos;Taobao&apos;, &apos;https://www.taobao.com&apos;)(5, &apos;stackoverflow&apos;, &apos;https://www.stackoverflow.com/&apos;)(1, &apos;RUNOOB&apos;, &apos;https://www.runoob.com&apos;)(2, &apos;Google&apos;, &apos;https://www.google.com&apos;)(3, &apos;Github&apos;, &apos;https://www.github.com&apos;) 限制查询的数据量指定起始位置，读取前 3 条记录. 例如，从第二条开始读取前 3 条记录：123456mycursor.execute("SELECT * FROM sites LIMIT 3 OFFSET 1") # 0 为 第一条，1 为第二条，以此类推 myresult = mycursor.fetchall() for x in myresult: print(x) 执行代码，输出结果为：123(2, &apos;Google&apos;, &apos;https://www.google.com&apos;)(3, &apos;Github&apos;, &apos;https://www.github.com&apos;)(4, &apos;Taobao&apos;, &apos;https://www.taobao.com&apos;) 删除记录1234567sql = "DELETE FROM sites WHERE name = 'stackoverflow'" mycursor.execute(sql) mydb.commit() print(mycursor.rowcount, " 条记录删除") 执行代码，输出结果为：11 条记录删除 注意：要慎重使用删除语句，删除语句要确保指定了 WHERE 条件语句，否则会导致整表数据被删除。 为了防止数据库查询发生 SQL 注入的攻击，我们可以使用 %s 占位符来转义删除语句的条件： 12sql = "DELETE FROM sites WHERE name = %s"na = ("stackoverflow", ) 更新表数据12345678sql = "UPDATE sites SET name = 'ZH' WHERE name = 'Zhihu'" mycursor.execute(sql) mydb.commit() print(mycursor.rowcount, " 条记录被修改")执行代码，输出结果为： 使用 %s 占位符来转义更新语句的条件：12sql = "UPDATE sites SET name = %s WHERE name = %s"val = ("Zhihu", "ZH") 删除表123sql = "DROP TABLE IF EXISTS sites" # 删除数据表 sites mycursor.execute(sql) PyMySQL 驱动PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，Python2中则使用mysqldb。 PyMySQL 遵循 Python 数据库 API v2.0 规范，并包含了 pure-Python MySQL 客户端库。 安装 命令： 1pip install PyMySQL pycharm 的setting里面安装pymysql包 操作在操作之前确保：1.您已经创建了数据库 TESTDB.2.在TESTDB数据库中您已经创建了表 EMPLOYEE3.EMPLOYEE表字段为 FIRST_NAME, LAST_NAME, AGE, SEX 和 INCOME。 数据库连接123456789101112131415161718import pymysql # 打开数据库连接db = pymysql.connect("localhost","testuser","test123","TESTDB" ) # 使用 cursor() 方法创建一个游标对象 cursorcursor = db.cursor() # 使用 execute() 方法执行 SQL 查询 cursor.execute("SELECT VERSION()") # 使用 fetchone() 方法获取单条数据.data = cursor.fetchone() print ("Database version : %s " % data) # 关闭数据库连接db.close() 创建数据库表1234567891011121314151617181920212223import pymysql # 打开数据库连接db = pymysql.connect("localhost","testuser","test123","TESTDB" ) # 使用 cursor() 方法创建一个游标对象 cursorcursor = db.cursor() # 使用 execute() 方法执行 SQL，如果表存在则删除cursor.execute("DROP TABLE IF EXISTS EMPLOYEE") # 使用预处理语句创建表sql = """CREATE TABLE EMPLOYEE ( FIRST_NAME CHAR(20) NOT NULL, LAST_NAME CHAR(20), AGE INT, SEX CHAR(1), INCOME FLOAT )""" cursor.execute(sql) # 关闭数据库连接db.close() 插入操作1234567891011121314151617# 部分代码省略# SQL 插入语句sql = """INSERT INTO EMPLOYEE(FIRST_NAME, LAST_NAME, AGE, SEX, INCOME) VALUES ('Mac', 'Mohan', 20, 'M', 2000)"""try: # 执行sql语句 cursor.execute(sql) # 提交到数据库执行 db.commit()except: # 如果发生错误则回滚 db.rollback() # 关闭数据库连接db.close() 也可以写成如下形式：12345# SQL 插入语句sql = "INSERT INTO EMPLOYEE(FIRST_NAME, \ LAST_NAME, AGE, SEX, INCOME) \ VALUES ('%s', '%s', %s, '%s', %s)" % \ ('Mac', 'Mohan', 20, 'M', 2000) 查询操作Python查询Mysql使用 fetchone() 方法获取单条数据, 使用fetchall() 方法获取多条数据。 fetchone(): 该方法获取下一个查询结果集。结果集是一个对象 fetchall(): 接收全部的返回结果行. rowcount: 这是一个只读属性，并返回执行execute()方法后影响的行数。 查询EMPLOYEE表中salary（工资）字段大于1000的所有数据： 12345678910111213141516171819202122# SQL 查询语句sql = "SELECT * FROM EMPLOYEE \ WHERE INCOME &gt; %s" % (1000)try: # 执行SQL语句 cursor.execute(sql) # 获取所有记录列表 results = cursor.fetchall() for row in results: fname = row[0] lname = row[1] age = row[2] sex = row[3] income = row[4] # 打印结果 print ("fname=%s,lname=%s,age=%s,sex=%s,income=%s" % \ (fname, lname, age, sex, income ))except: print ("Error: unable to fetch data") # 关闭数据库连接db.close() 更新操作将 TESTDB 表中 SEX 为 ‘M’ 的 AGE 字段递增 1： 1sql = "UPDATE EMPLOYEE SET AGE = AGE + 1 WHERE SEX = '%c'" % ('M') 删除操作删除数据表 EMPLOYEE 中 AGE 大于 20 的所有数据：12# SQL 删除语句sql = "DELETE FROM EMPLOYEE WHERE AGE &gt; %s" % (20)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>python</tag>
        <tag>PyMySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Django框架]]></title>
    <url>%2F2019%2F04%2F11%2F%E5%AD%A6%E4%B9%A0Django%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[介绍Django是一个开放源代码的Web应用框架，由Python写成。 安装 pycharm社区版创建django项目：pycharm自带django数据包 项目pycharm创建第一个django请求步骤 在你要创建项目的目录下执行cmd命令1django-admin.py startproject 文件名 执行之后可以看到项目的目录结构1234567hellodjango|-- hellodjango| |-- __init__.py| |-- settings.py| |-- urls.py| `-- wsgi.py`-- manage.py 运行:我们进入 hellodjango 目录(pycharm下，点击 Terminal)，输入以下命令，启动服务器： 1python3 manage.py runserver 127.0.0.1:8000 打开显示的网址()，可以看到第一个django请求运行成功. ####### 目录说明： HelloWorld: 项目的容器。 manage.py: 一个实用的命令行工具，可让你以各种方式与该 Django 项目进行交互。 HelloWorld/init.py: 一个空文件，告诉 Python 该目录是一个 Python 包。 HelloWorld/settings.py: 该 Django 项目的设置/配置。 HelloWorld/urls.py: 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站”目录”。 HelloWorld/wsgi.py: 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目。配置在settings.py文件中修改： 模板路径配置（html） 123456789TEMPLATES = [ &#123; ... 'DIRS': [os.path.join(BASE_DIR,'templates')], # os.path.join(BASE_DIR）表示基目录，你的project目录 # 'templates'表示模板路径 ... &#125;,] 静态文件配置（图片，css文件, js文件） 1234STATIC_URL = &apos;/static/&apos; # 使用时前缀STATICFILES_DIRS=( os.path.join(BASE_DIR,&apos;static&apos;), # 真实路径，干脆直接写成&apos;static&apos;) 注意：逗号不能少！！！ 额外配置（csrf注释） 123456789MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',] 路由关系(url对应关系)url—&gt;函数 注释自带的url(path)，按照自带格式创建你的页面12# path(&apos;admin/&apos;, admin.site.urls), url(r&apos;^login/&apos;,login), 处理请求函数先看整体代码： 123456789101112131415161718192021222324from django.shortcuts import HttpResponse,render,redirectdef login(request): # return HttpResponse('hahahhahahah') # 自动找到模板路径下的html文件，读取类容并返回给用户 print(request.GET) if request.method=="GET": # 模板渲染 return render(request,'login.html') else: # 用户post提交的数据（请求体） u = request.POST.get('username') p = request.POST.get('password') if u=='root'and p=='123123': # 登陆成功,跳转到其他页面 return redirect('https://www.youdao.com/') else: # 登陆失败 return render(request,'login.html',&#123;'msg':'用户名或密码错误'&#125;)urlpatterns = [ # path('admin/', admin.site.urls), url(r'^login/',login),] 步骤说明： 导入包 1from django.shortcuts import HttpResponse,render,redirect 定义函数 123def indox(request): 函数体 request的两种方法（request.method）: request.GET , 从请求头中的url拿到值， GET请求只有request.GET有值 request.POST ,从请求头中拿到值， POST请求request.GET和request.POST都可能有值 request表示用户请求相关的所有信息（对象） 三种返回方式： return HttpResponse（”字符串”），只能在页面上显示支付串 return render(函数参数（request）,’模板路径’（login.html），{})， 自带找到模板路径下的login.html，读取内容并返回给用户，模板路径是templates以后的路径。 return redirect(‘URL’)，跳转到要跳转的网址（可以是其他网站，也可以是自己的网址） 说明：在前面我们已经配置过模板路径和静态文件路径,所以可以直接运用自己web网页设计知识对你的页面进行设计、美化和动态交互，记得在你html文件中要连接css、js或图片文件时，前面添加路径（/static/），例如：1&lt;link rel=&quot;stylesheet&quot; href=&quot;/static/commons.css&quot;/&gt; 模板标签过滤器urls.py123456789def index(request):return render(request,'模板路径‘)，&#123; 'k1':'v1', 'k2':[1,2,32,34],#列表 'k3':&#123;'k1':'v1','k2':'v2',...&#125;,# 字典 'user_list_dict':[&#123;&#125;] ，#列表[字典]&#125;) index.html123&lt;h1&gt;&#123;&#123;k1&#125;&#125;&lt;/h1&gt;&lt;h1&gt;&#123;&#123;k2.2&#125;&#125;&lt;/h1&gt;&lt;h1&gt;&#123;&#123;k3.&#125;&#125;&lt;/h1&gt; 模板过滤器可以在变量被显示前修改它，过滤器使用管道字符，如下所示： 1&#123;&#123; name|lower &#125;&#125; name 变量被过滤器 lower 处理后，文档大写转换文本为小写。 过滤管道可以被 套接 ，既是说，一个过滤器管道的输出又可以作为下一个管道的输入：1&#123;&#123; my_list|first|upper &#125;&#125; 以上实例将第一个元素并将其转化为大写。 有些过滤器有参数。 过滤器的参数跟随冒号之后并且总是以双引号包含。 例如：1&#123;&#123; bio|truncatewords:&quot;30&quot; &#125;&#125; 这个将显示变量 bio 的前30个词。 其他过滤器： addslashes : 添加反斜杠到任何反斜杠、单引号或者双引号前面。 date : 按指定的格式字符串参数格式化 date 或者 datetime 对象，实例： 1&#123;&#123; pub_date|date:&quot;F j, Y&quot; &#125;&#125; length : 返回变量的长度。 说明：django标签通过 ‘.’ 索引 if/else 标签基本语法格式如下： 123&#123;% if condition %&#125; ... display&#123;% endif %&#125; 或者：1234567&#123;% if condition1 %&#125; ... display 1&#123;% elif condition2 %&#125; ... display 2&#123;% else %&#125; ... display 3&#123;% endif %&#125; 根据条件判断是否输出。if/else 支持嵌套。 说明： if 标签接受 and ， or 或者 not 关键字来对多个变量做判断 ，或者对变量取反（ not )。 循环123456&lt;h3&gt;循环&lt;/h3&gt;&lt;ul&gt;&#123;% for item in users%&#125; &lt;li&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; 说明： 可以与html搭配使用 ifequal/ifnotequal 标签 ifequal 标签比较两个值，当他们相等时，显示在 ifequal 和 endifequal 之中所有的值。 下面的例子比较两个模板变量 user 和 currentuser : 123&#123;% ifequal user currentuser %&#125; &lt;h1&gt;Welcome!&lt;/h1&gt;&#123;% endifequal %&#125; 和 if 类似， ifequal 支持可选的 else标签： 12345&#123;% ifequal section 'sitenews' %&#125; &lt;h1&gt;Site News&lt;/h1&gt;&#123;% else %&#125; &lt;h1&gt;No News Here&lt;/h1&gt;&#123;% endifequal %&#125; 注释标签Django 注释使用 。 1&#123;# 这是一个注释 #&#125; include 标签 include 标签允许在模板中包含其它的模板的内容。 下面这个例子都包含了 nav.html 模板：1&#123;% include &quot;nav.html&quot; %&#125; 模板继承模板可以用继承的方式来实现复用。 接下来我们先创建之前项目的 templates 目录中添加 father.html 文件，代码如下： mysites/templates/father.html 文件代码：1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;模板继承&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;p&gt;Django 测试。&lt;/p&gt; &#123;% block mainbody %&#125; &lt;p&gt;original&lt;/p&gt; &#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; 以上代码中，名为 mainbody 的 block 标签是可以被继承者们替换掉的部分。 所有的 block 标签告诉模板引擎，子模板可以重载这些部分。 son.html 中继承 father.html，并替换特定 block，son.html 修改后的代码如下： mysites/templates/son.html 文件代码： 12345&#123;%extends "father.html" %&#125; &#123;% block mainbody %&#125;&lt;p&gt;继承了 base.html 文件&lt;/p&gt;&#123;% endblock %&#125; 第一行代码说明 son.html 继承了 father.html 文件。可以看到，这里相同名字的 block 标签用以替换 father.html 的相应 block。 django模型Django 对各种数据库提供了很好的支持，包括：PostgreSQL、MySQL、SQLite、Oracle。 Django 为这些数据库提供了统一的调用API。 安装mysqlclient直接在pycharm的setting里面导入mysqlclient包,如果提示安装错误可以查看下面的链接：mysqlclient安装出错 数据库配置我们在项目的 settings.py 文件中找到 DATABASES 配置项，将其信息修改为：12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', # 或者使用 mysql.connector.django 'NAME': 'test_db',# 数据库名称 'USER': 'root',# 用户 'PASSWORD': 'an1234',# 密码 'HOST':'localhost',# ip 'PORT':'3306',# 端口 &#125;&#125; 注意：这里添加了中文注释，所以你需要在 HelloWorld/settings.py 文件头部添加 # -- coding: UTF-8 --。 上面包含数据库名称和用户的信息，它们与 MySQL 中对应数据库和用户的设置相同。Django 根据这一设置，与 MySQL 中相应的数据库和用户连接起来。 定义模型 创建 APPDjango规定，如果要使用模型，必须要创建一个app。我们使用以下命令创建一个 TestModel 的 app: 1django-admin startapp TestModel 目录结构如下：1234567Hellodjango|-- TestModel| |-- __init__.py| |-- admin.py| |-- models.py| |-- tests.py| `-- views.py 修改 TestModel/models.py 文件： 1234from django.db import modelsclass Test(models.Model): name = models.CharField(max_length=20) 接下来在settings.py中找到INSTALLED_APPS这一项，如下： 123456789INSTALLED_APPS = ( &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, &apos;TestModel&apos;, # 添加此项) 在命令行中运行： 12345$ python manage.py migrate # 创建表结构$ python manage.py makemigrations TestModel # 让 Django 知道我们在我们的模型有一些变更$ python manage.py migrate TestModel # 创建表结构 看到几行 “Creating table…” 的字样，你的数据表就创建好了。1234Creating tables ...……Creating table TestModel_test #我们自定义的表…… 表名组成结构为：应用名_类名（如：TestModel_test）。 注意：尽管我们没有在models给表设置主键，但是Django会自动添加一个id作为主键。 接下来你就可以对数据库进行操作了 相关链接 python3 django配置数据库（mysql） Django中数据库配置 Django 配置MySQL数据库 [Django] Django(五) 配置mysql数据库 django-数据库【配置】]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python巩固]]></title>
    <url>%2F2019%2F03%2F30%2Fpython%E5%B7%A9%E5%9B%BA%2F</url>
    <content type="text"><![CDATA[巩固python基础 中文编码Python中默认的编码格式是 ASCII 格式，在没修改编码格式时无法正确打印汉字，所以在读取中文时会报错。解决方法为只要在文件开头加入 # -*- coding: UTF-8 -*- 或者 #coding=utf-8 就行了 注意：**#coding=utf-8 的 =** 号两边不要空格。 标识符 以下划线开头的标识符是有特殊意义的。以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入。 以双下划线开头的 __foo 代表类的私有成员，以双下划线开头和结尾的 foo 代表 Python 里特殊方法专用的标识，如 init() 代表类的构造函数。 行和缩进学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。 多行语句Python语句中一般以新行作为语句的结束符。 但是我们可以使用斜杠（ \）将一行的语句分为多行显示，如下所示：123total = item_one + \ item_two + \ item_three 语句中包含 [], {} 或 () 括号就不需要使用多行连接符。 Print 输出print 默认输出是换行的，如果要实现不换行需要在变量末尾加上逗号 , 12345678910111213# -*- coding: UTF-8 -*-x="a"y="b"# 换行输出print xprint yprint '---------'# 不换行输出print x,print y,# 不换行输出print x,y 以上实例执行结果为： a ba b a b 标准数据类型Python有五个标准的数据类型： Numbers（数字） String（字符串） List（列表） Tuple（元组） Dictionary（字典） 数字 长整型也可以使用小写 l，但是还是建议您使用大写 L，避免与数字 1 混淆。Python使用 L 来显示长整型。 Python 还支持复数，复数由实数部分和虚数部分构成，可以用 a + bj,或者 complex(a,b) 表示， 复数的实部 a 和虚部 b 都是浮点型。注意：long 类型只存在于 Python2.X 版本中，在 2.2 以后的版本中，int 类型数据溢出后会自动转为long类型。在 Python3.X 版本中 long 类型被移除，使用 int 替代。 字符串python的字串列表有2种取值顺序: 从左到右索引默认0开始的，最大范围是字符串长度少1 从右到左索引默认-1开始的，最大范围是字符串开头实例12345678910# -*- coding: UTF-8 -*- str = 'Hello World!' print str # 输出完整字符串print str[0] # 输出字符串中的第一个字符print str[2:5] # 输出字符串中第三个至第五个之间的字符串print str[2:] # 输出从第三个字符开始的字符串print str * 2 # 输出字符串两次print str + "TEST" # 输出连接的字符串 以上实例输出结果： Hello World!Hllollo World!Hello World!Hello World!Hello World!TEST Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串： 列表List（列表） 是 Python 中使用最频繁的数据类型。列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。列表用 [ ] 标识，是 python 最通用的复合数据类型。 列表方法 序号 方法 1 list.append(obj) 在列表末尾添加新的对象 2 list.count(obj) 统计某个元素在列表中出现的次数 3 list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） 4 list.index(obj) 从列表中找出某个值第一个匹配项的索引位置 5 list.insert(index, obj) 将对象插入列表 6 list.pop([index=-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 7 list.remove(obj) 移除列表中某个值的第一个匹配项 8 list.reverse() 反向列表中元素 9 list.sort(cmp=None, key=None, reverse=False) 对原列表进行排序 实例1234567# -*- coding: UTF-8 -*- # 列表vowels = ['e', 'a', 'u', 'o', 'i']# 降序vowels.sort(reverse=True)# 输出结果print '降序输出:', vowel 以上实例输出结果如下： 降序输出: [‘u’, ‘o’, ‘i’, ‘e’, ‘a’] 元组元组是另一个数据类型，类似于 List（列表）。元组用 , 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。 创建空元组 tup1 = () 元组中只包含一个元素时，需要在元素后面添加逗号 tup1 = (50,) 实例1234567891011# -*- coding: UTF-8 -*-tuple = ( 'runoob', 786 , 2.23, 'john', 70.2 )tinytuple = (123, 'john') print tuple # 输出完整元组print tuple[0] # 输出元组的第一个元素print tuple[1:3] # 输出第二个至第三个的元素 print tuple[2:] # 输出从第三个开始至列表末尾的所有元素print tinytuple * 2 # 输出元组两次print tuple + tinytuple # 打印组合的元组 以上实例输出结果： (‘runoob’, 786, 2.23, ‘john’, 70.2)runoob(786, 2.23)(2.23, ‘john’, 70.2)(123, ‘john’, 123, ‘john’)(‘runoob’, 786, 2.23, ‘john’, 70.2, 123, ‘john’) 字典字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。字典用”{ }”标识。字典由索引(key)和它对应的值value组成。 删除字典元素####### 实例123456# -*- coding: UTF-8 -*-dict = &#123;'Name': 'Zara', 'Age': 7, 'Class': 'First'&#125; del dict['Name'] # 删除键是'Name'的条目dict.clear() # 清空词典所有条目del dict # 删除词典 内置方法： 序号 函数及描述 1 dict.clear() 删除字典内所有元素 2 dict.copy() 返回一个字典的浅复制 3 dict.fromkeys(seq[, val]) 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值 4 dict.get(key, default=None) 返回指定键的值，如果值不在字典中返回default值 5 dict.has_key(key) 如果键在字典dict里返回true，否则返回false 6 dict.items() 以列表返回可遍历的(键, 值) 元组数组 7 dict.keys() 以列表返回一个字典所有的键 8 dict.setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default 9 dict.update(dict2) 把字典dict2的键/值对更新添加到dict里 10 dict.values() 以列表返回字典中的所有值 11 pop(key[,default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 12 popitem() 随机返回并删除字典中的一对键和值。 ####### 实例以下实例展示了 fromkeys()函数的使用方法： 123456789# -*- coding: UTF-8 -*- seq = ('Google', 'Runoob', 'Taobao') dict = dict.fromkeys(seq)print "新字典为 : %s" % str(dict) dict = dict.fromkeys(seq, 10)print "新字典为 : %s" % str(dict) 以上实例输出结果为： 新字典为 : {‘Google’: None, ‘Taobao’: None, ‘Runoob’: None}新字典为 : {‘Google’: 10, ‘Taobao’: 10, ‘Runoob’: 10} 实例123456789101112# -*- coding: UTF-8 -*- dict = &#123;&#125;dict['one'] = "This is one"dict[2] = "This is two"tinydict = &#123;'name': 'john','code':6734, 'dept': 'sales'&#125; print dict['one'] # 输出键为'one' 的值print dict[2] # 输出键为 2 的值print tinydict # 输出完整的字典print tinydict.keys() # 输出所有键print tinydict.values() # 输出所有值 输出结果为： This is oneThis is two{‘dept’: ‘sales’, ‘code’: 6734, ‘name’: ‘john’}[‘dept’, ‘code’, ‘name’][‘sales’, 6734, ‘john’] 运算符算数运算符 ** 幂 - 返回x的y次幂 a**b 为10的20次方， 输出结果 100000000000000000000 // 取整除 - 返回商的整数部分（向下取整） &gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5 位运算符 运算符 描述 实例 &amp; 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a &amp; b) 输出结果 12 ，二进制解释： 0000 1100 &#124; 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 (a &#124; b) 输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。 &lt;&lt; 左移动运算符：运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数字指定了移动的位数，高位丢弃，低位补0。 a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000 &gt;&gt; 右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，&gt;&gt; 右边的数字指定了移动的位数 a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111 逻辑运算符Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20: 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 成员运算符除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 身份运算符身份运算符用于比较两个对象的存储单元 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。 is 与 == 区别：is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。 字符串运算符 运算符 描述 r/R 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母”r”（可以大小写）以外，与普通字符串有着几乎完全相同的语法。 &gt;&gt;&gt;print r’\n’ \n &gt;&gt;&gt; print R’\n’ \n 运算符优先级以下表格列出了从最高到最低优先级的所有运算符： 运算符 描述 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，取模和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算符 &amp; 位 ‘AND’ ^ \ &#124; 位运算符 &lt;= &lt; &gt; &gt;= 比较运算符 &lt;&gt; == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not and or 逻辑运算符 语句 python 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现，如果判断需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功。 pass 语句Python pass 是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。 实例：12345678910# -*- coding: UTF-8 -*- # 输出 Python 的每个字母for letter in 'Python': if letter == 'h': pass print '这是 pass 块' print '当前字母 :', letter print "Good bye!" 以上实例执行结果： 当前字母 : P当前字母 : y当前字母 : t这是 pass 块当前字母 : h当前字母 : o当前字母 : nGood bye! 数学函数math 模块、cmath 模块Python 中数学运算常用的函数基本都在 math 模块、cmath 模块中。 Python math 模块提供了许多对浮点数的数学运算函数。 Python cmath 模块包含了一些用于复数运算的函数。 cmath 模块的函数跟 math 模块函数基本一致，区别是 cmath 模块运算的是复数，math 模块运算的是数学运算。 查看 math 查看包中的内容:1234&gt;&gt;&gt; import math&gt;&gt;&gt; dir(math)['__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf', 'nan', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau', 'trunc']&gt;&gt;&gt; 查看 cmath 查看包中的内容1234&gt;&gt;&gt; import cmath&gt;&gt;&gt; dir(cmath)['__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'cos', 'cosh', 'e', 'exp', 'inf', 'infj', 'isclose', 'isfinite', 'isinf', 'isnan', 'log', 'log10', 'nan', 'nanj', 'phase', 'pi', 'polar', 'rect', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'tau']&gt;&gt;&gt; Python数学函数 函数 返回值 ( 描述 ) abs(x) 返回数字的绝对值，如abs(-10) 返回 10 ceil(x) 返回数字的上入整数，如math.ceil(4.1) 返回 5 cmp(x, y) 如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1 exp(x) 返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045 fabs(x) 返回数字的绝对值，如math.fabs(-10) 返回10.0 floor(x) 返回数字的下舍整数，如math.floor(4.9)返回 4 log(x) 如math.log(math.e)返回1.0,math.log(100,10)返回2.0 log10(x) 返回以10为基数的x的对数，如math.log10(100)返回 2.0 max(x1, x2,…) 返回给定参数的最大值，参数可以为序列。 min(x1, x2,…) 返回给定参数的最小值，参数可以为序列。 modf(x) 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。 pow(x, y) x**y 运算后的值。 round(x [,n]) 返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。 sqrt(x) 返回数字x的平方根 Python随机数函数随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。 Python包含以下常用随机数函数： 函数 描述 choice(seq) 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。 randrange ([start,] stop [,step]) 从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1 random() 随机生成下一个实数，它在[0,1)范围内。 seed([x]) 改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。 shuffle(lst) 将序列的所有元素随机排序 uniform(x, y) 随机生成下一个实数，它在[x,y]范围内。 Python三角函数Python包括以下三角函数： 函数 描述 acos(x) 返回x的反余弦弧度值。 asin(x) 返回x的反正弦弧度值。 atan(x) 返回x的反正切弧度值。 atan2(y, x) 返回给定的 X 及 Y 坐标值的反正切值。 cos(x) 返回x的弧度的余弦值。 hypot(x, y) 返回欧几里德范数 sqrt(xx + yy)。 sin(x) 返回的x弧度的正弦值。 tan(x) 返回x弧度的正切值。 degrees(x) 将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0 radians(x) 将角度转换为弧度 Python数学常量 常量 描述 pi 数学常量 pi（圆周率，一般以π来表示） e 数学常量 e，e即自然常数（自然常数）。 时间time时间间隔是以秒为单位的浮点小数。 每个时间戳都以自从1970年1月1日午夜（历元）经过了多长时间来表示。 Python 的 time 模块下有很多函数可以转换常见日期格式。如函数time.time()用于获取当前时间戳, Time 模块Time 模块包含了以下内置函数，既有时间处理的，也有转换时间格式的： 序号 函数及描述 1 time.altzone 返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。 2 time.asctime([tupletime]) 接受时间元组并返回一个可读的形式为”Tue Dec 11 18:07:14 2008”（2008年12月11日 周二18时07分14秒）的24个字符的字符串。 3 time.clock( ) 用以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。 4 time.ctime([secs]) 作用相当于asctime(localtime(secs))，未给参数相当于asctime() 5 time.gmtime([secs]) 接收时间戳（1970纪元后经过的浮点秒数）并返回格林威治天文时间下的时间元组t。注：t.tm_isdst始终为0 6 time.localtime([secs]) 接收时间戳（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组t（t.tm_isdst可取0或1，取决于当地当时是不是夏令时）。 7 time.mktime(tupletime) 接受时间元组并返回时间戳（1970纪元后经过的浮点秒数）。 8 time.sleep(secs) 推迟调用线程的运行，secs指秒数。 9 time.strftime(fmt[,tupletime]) 接收以时间元组，并返回以可读字符串表示的当地时间，格式由fmt决定。 10 time.strptime(str,fmt=’%a %b %d %H:%M:%S %Y’) 根据fmt的格式把一个时间字符串解析为时间元组。 11 time.time( ) 返回当前时间的时间戳（1970纪元后经过的浮点秒数）。 12 time.tzset() 根据环境变量TZ重新初始化时间相关设置。 实例以下实例展示了 time() 函数的使用方法：123456#!/usr/bin/pythonimport timeprint "time.time(): %f " % time.time()print time.localtime( time.time() )print time.asctime( time.localtime(time.time()) ) 运行结果： 1553931680.6086578time.struct_time(tm_year=2019, tm_mon=3, tm_mday=30, tm_hour=15, tm_min=41, tm_sec=57, tm_wday=5, tm_yday=89, tm_isdst=0)Sat Mar 30 15:43:23 2019 日历（Calendar）模块此模块的函数都是日历相关的，例如打印某月的字符月历。 星期一是默认的每周第一天，星期天是默认的最后一天。更改设置需调用calendar.setfirstweekday()函数。模块包含了以下内置函数： 序号 函数及描述 1 calendar.calendar(year,w=2,l=1,c=6) 返回一个多行字符串格式的year年年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为21 W+18+2 C。l是每星期行数。 2 calendar.firstweekday( ) 返回当前每周起始日期的设置。默认情况下，首次载入caendar模块时返回0，即星期一。 3 calendar.isleap(year) 是闰年返回 True，否则为 False。` 4 calendar.leapdays(y1,y2) 返回在Y1，Y2两年之间的闰年总数。 5 calendar.month(year,month,w=2,l=1) 返回一个多行字符串格式的year年month月日历，两行标题，一周一行。每日宽度间隔为w字符。每行的长度为7* w+6。l是每星期的行数。 6 calendar.monthcalendar(year,month) 返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数。Year年month月外的日期都设为0;范围内的日子都由该月第几日表示，从1开始。 7 calendar.monthrange(year,month) 返回两个整数。第一个是该月的星期几的日期码，第二个是该月的日期码。日从0（星期一）到6（星期日）;月从1到12。 8 calendar.prcal(year,w=2,l=1,c=6) 相当于 print calendar.calendar(year,w,l,c). 9 calendar.prmonth(year,month,w=2,l=1) 相当于 print calendar.calendar（year，w，l，c）。 10 calendar.setfirstweekday(weekday) 设置每周的起始日期码。0（星期一）到6（星期日）。 11 calendar.timegm(tupletime) 和time.gmtime相反：接受一个时间元组形式，返回该时刻的时间戳（1970纪元后经过的浮点秒数）。 12 calendar.weekday(year,month,day) 返回给定日期的日期码。0（星期一）到6（星期日）。月份为 1（一月） 到 12（12月）。 实例获取某月日历Calendar模块有很广泛的方法用来处理年历和月历，例如打印某月的月历： 1234567# -*- coding: UTF-8 -*- import calendar cal = calendar.month(2019, 3)print "以下输出2019年3月份的日历:"print cal 运行结果： March 2019 Mo Tu We Th Fr Sa Su 1 2 3 4 5 6 7 8 9 1011 12 13 14 15 16 1718 19 20 21 22 23 2425 26 27 28 29 30 31 函数定义一个函数你可以定义一个由自己想要功能的函数，以下是简单的规则： 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()。 任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。 函数内容以冒号起始，并且缩进。 return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。 可更改(mutable)与不可更改(immutable)对象在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。 python 函数的参数传递： 不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响 实例1234567# -*- coding: UTF-8 -*-def ChangeInt( a ): a = 10 b = 2ChangeInt(b)print b # 结果是 2 参数以下是调用函数时可使用的正式参数类型： 必备参数 关键字参数 默认参数 不定长参数 不定长参数你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，声明时不会命名。基本语法如下：1234def functionname([formal_args,] *var_args_tuple ): "函数_文档字符串" function_suite return [expression] 加了星号（*）的变量名会存放所有未命名的变量参数。不定长参数实例如下： ####### 实例1234567891011121314# -*- coding: UTF-8 -*- # 可写函数说明def printinfo( arg1, *vartuple ): "打印任何传入的参数" print "输出: " print arg1 for var in vartuple: print var return; # 调用printinfo 函数printinfo( 10 );printinfo( 70, 60, 50 ); 以上实例输出结果： 输出:10输出:706050 匿名函数python 使用 lambda 来创建匿名函数。 lambda只是一个表达式，函数体比def简单很多。 lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。 lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。 虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。语法lambda函数的语法只包含一个语句，如下： lambda [arg1 [,arg2,…..argn]]:expression 实例12345678# -*- coding: UTF-8 -*- # 可写函数说明sum = lambda arg1, arg2: arg1 + arg2; # 调用sum函数print "相加后的值为 : ", sum( 10, 20 )print "相加后的值为 : ", sum( 20, 20 ) 以上实例输出结果： 相加后的值为 : 30相加后的值为 : 40 Python中的包包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。 简单来说，包就是文件夹，但该文件夹下必须存在 init.py 文件, 该文件的内容可以为空。init.py 用于标识当前文件夹是一个包。例如：考虑一个在 package_runoob 目录下的 runoob1.py、runoob2.py、init.py 文件，test.py 为测试调用包的代码，目录结构如下：12345678910111213test.pypackage_runoob|-- __init__.py|-- runoob1.py|-- runoob2.py 源代码如下：package_runoob/runoob1.py​```python# -*- coding: UTF-8 -*-def runoob1(): print "I'm in runoob1" package_runoob/runoob2.py 1234# -*- coding: UTF-8 -*-def runoob2(): print "I'm in runoob2" 现在，在 package_runoob 目录下创建 init.py： package_runoob/init.py1234567# -*- coding: UTF-8 -*-if __name__ == '__main__': print '作为主程序运行'else: print 'package_runoob 初始化' 然后我们在 package_runoob 同级目录下创建 test.py 来调用 package_runoob 包 test.py12345678# -*- coding: UTF-8 -*-# 导入 Phone 包from package_runoob.runoob1 import runoob1from package_runoob.runoob2 import runoob2runoob1()runoob2() 以上实例输出结果： package_runoob 初始化I’m in runoob1I’m in runoob2 文件读取键盘输入Python提供了两个内置函数从标准输入读入一行文本，默认的标准输入是键盘。如下： raw_input inputraw_input函数raw_input([prompt]) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）： ####### 实例1234# -*- coding: UTF-8 -*- str = raw_input("请输入：")print "你输入的内容是: ", str 这会产生如下的对应着输入的结果： 请输入：Hello Python！你输入的内容是: Hello Python！ input函数input([prompt]) 函数和 raw_input([prompt]) 函数基本类似，但是 input 可以接收一个Python表达式作为输入，并将运算结果返回。 ####### 实例1234# -*- coding: UTF-8 -*- str = input("请输入：")print "你输入的内容是: ", str 这会产生如下的对应着输入的结果： 请输入：[x*5 for x in range(2,10,2)]你输入的内容是: [10, 20, 30, 40] 打开和关闭文件Python 提供了必要的函数和方法进行默认情况下的文件基本操作。你可以用 file 对象做大部分的文件操作。 open 函数你必须先用Python内置的open()函数打开一个文件，创建一个file对象，相关的方法才可以调用它进行读写。 语法： 1file object = open(file_name [, access_mode][, buffering]) 各个参数的细节如下： file_name：file_name变量是一个包含了你要访问的文件名称的字符串值。 access_mode：access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。 buffering:如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。 注意：使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法。 open() 函数常用形式是接收两个参数：文件名(file)和模式(mode)。 1open(file, mode=&apos;r&apos;) 完整的语法格式为： 1open(file, mode=&apos;r&apos;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) 参数说明: file: 必需，文件路径（相对或者绝对路径）。 mode: 可选，文件打开模式 buffering: 设置缓冲 encoding: 一般使用utf8 errors: 报错级别 newline: 区分换行符 closefd: 传入的file参数类型 opener: 不同模式打开文件的完全列表： 模式 描述 t 文本模式 (默认)。 x 写模式，新建一个文件，如果该文件已存在则会报错。 b 二进制模式。 + 打开一个文件进行更新(可读可写)。 U 通用换行模式（不推荐）。 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 File对象的属性一个文件被打开后，你有一个file对象，你可以得到有关该文件的各种信息。 以下是和file对象相关的所有属性的列表： 属性 描述 file.closed 返回true如果文件已被关闭，否则返回false。 file.mode 返回被打开文件的访问模式。 file.name 返回文件的名称。 file.softspace 如果用print输出后，必须跟一个空格符，则返回false。否则返回true。 如下实例： 12345678# -*- coding: UTF-8 -*- # 打开一个文件fo = open("foo.txt", "w")print "文件名: ", fo.nameprint "是否已关闭 : ", fo.closedprint "访问模式 : ", fo.modeprint "末尾是否强制加空格 : ", fo.softspace 以上实例输出结果： 1234文件名: foo.txt是否已关闭 : False访问模式 : w末尾是否强制加空格 : 0 write()方法write()方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。 write()方法不会在字符串的结尾添加换行符(‘\n’)： read()方法read（）方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。语法： fileObject.read([count]) 在这里，被传递的参数是要从已打开文件中读取的字节计数。该方法从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾。 文件定位 tell()方法告诉你文件内的当前位置, 换句话说，下一次的读写会发生在文件开头这么多字节之后。 seek（offset [,from]）方法改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。如果from被设为0，这意味着将文件的开头作为移动字节的参考位置。如果设为1，则使用当前的位置作为参考位置。如果它被设为2，那么该文件的末尾将作为参考位置。 重命名和删除文件Python的os模块提供了帮你执行文件处理操作的方法，比如重命名和删除文件。 要使用这个模块，你必须先导入它，然后才可以调用相关的各种功能。 ####### rename()方法： rename()方法需要两个参数，当前的文件名和新文件名。 语法： os.rename(current_file_name, new_file_name) ######## 实例下例将重命名一个已经存在的文件test1.txt。123456# -*- coding: UTF-8 -*-import os # 重命名文件test1.txt到test2.txt。os.rename( "test1.txt", "test2.txt" ) ####### remove()方法你可以用remove()方法删除文件，需要提供要删除的文件名作为参数。 语法： os.remove(file_name) ######## 实例下例将删除一个已经存在的文件test2.txt。12345# -*- coding: UTF-8 -*-import os# 删除一个已经存在的文件test2.txtos.remove("test2.txt") Python里的目录：所有文件都包含在各个不同的目录下，不过Python也能轻松处理。os模块有许多方法能帮你创建，删除和更改目录。目录方法 mkdir()方法可以使用os模块的mkdir()方法在当前目录下创建新的目录们。你需要提供一个包含了要创建的目录名称的参数。 语法： os.mkdir(“newdir”)例子： chdir()方法可以用chdir()方法来改变当前的目录。chdir()方法需要的一个参数是你想设成当前目录的目录名称。 语法： os.chdir(“newdir”) getcwd()方法：getcwd()方法显示当前的工作目录。 语法： os.getcwd() rmdir()方法rmdir()方法删除目录，目录名称以参数传递。 在删除这个目录之前，它的所有内容应该先被清除。 语法： os.rmdir(‘dirname’) 异常处理异常处理 try/except语句。try/except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。 如果你不想在异常发生时结束你的程序，只需在try里捕获它。 语法： 12345678try:&lt;语句&gt; #运行别的代码except &lt;名字&gt;：&lt;语句&gt; #如果在try部份引发了&apos;name&apos;异常except &lt;名字&gt;，&lt;数据&gt;:&lt;语句&gt; #如果引发了&apos;name&apos;异常，获得附加的数据else:&lt;语句&gt; #如果没有异常发生 try-finally 语句try-finally 语句无论是否发生异常都将执行最后的代码。语法 12345try:&lt;语句&gt;finally:&lt;语句&gt; #退出try时总会执行raise 实例以下为单个异常的实例： 12345678910# -*- coding: UTF-8 -*-# 定义函数def temp_convert(var): try: return int(var) except ValueError, Argument: print "参数没有包含数字\n", Argument# 调用函数temp_convert("xyz"); 以上程序执行结果如下： 123$ python test.py 参数没有包含数字invalid literal for int() with base 10: &apos;xyz&apos; 触发异常我们可以使用raise语句自己触发异常 raise语法格式如下： 1raise [Exception [, args [, traceback]]] 语句中 Exception 是异常的类型（例如，NameError）参数标准异常中任一种，args 是自已提供的异常参数。 最后一个参数是可选的（在实践中很少使用），如果存在，是跟踪异常对象。 实例一个异常可以是一个字符串，类或对象。 1234def functionName( level ): if level &lt; 1: raise Exception("Invalid level!", level) # 触发异常后，后面的代码就不会再执行 面向对象 getattr(obj, name[, default]) : 访问对象的属性。 hasattr(obj,name) : 检查是否存在一个属性。 setattr(obj,name,value) : 设置一个属性。如果属性不存在，会创建一个新属性。 delattr(obj, name) : 删除属性。 issubclass() - 布尔函数判断一个类是另一个类的子类或者子孙类，语法：issubclass(sub,sup) isinstance(obj, Class) 布尔函数如果obj是Class类的实例对象或者是一个Class子类的实例对象则返回true。 基础重载方法 序号 方法, 描述 &amp; 简单的调用 1 init ( self [,args…] ) 构造函数 简单的调用方法: obj = className(args) 2 del( self ) 析构方法, 删除一个对象 简单的调用方法 : del obj 3 repr( self ) 转化为供解释器读取的形式 简单的调用方法 : repr(obj) 4 str( self ) 用于将值转化为适于人阅读的形式 简单的调用方法 : str(obj) 5 cmp ( self, x ) 对象比较 简单的调用方法 : cmp(obj, x)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Choice]]></title>
    <url>%2F2019%2F03%2F29%2F%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[在学习java半途中投入python的怀抱 i take a long long time to think about what should i choose python or java so that my head get a headache.finally, i chose python. i still remember those days when i began to study python,it was my spiritual cereal,yes, i think it was! i thought it was a cool language so that i spent little time in thinking some mad but seem no matter thing,actually it “fuck them”. in the begining ,i was blind because many of my partners in laborattory chose java.i think maybe i could fall in love with it,i just need time,but unfortunately i feel unsafe and wandering in the process of learn java,on the contrary , i feel good if i choose python.for that decision ,i ask for some suggestion from the former member,i talk with thise parter, i sell my book in order to make sure my inner decision. i really really really decided, No matter where i can arrive ,i will try my best. 微笑着 旋转着 紧握着双手 整个世界旋转成模糊一片 你却屹立不移酩酊大醉 浑身湿透 脱掉胶鞋 裸足奔跑 破壳而出风中传来你 头发的味道 我深吸口气踏着水潭 浑身湿透 脱掉胶鞋即使满是鲜血 我仍昂然奋起]]></content>
      <categories>
        <category>感想</category>
      </categories>
      <tags>
        <tag>-日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习java]]></title>
    <url>%2F2019%2F03%2F27%2F%E5%AD%A6%E4%B9%A0java%2F</url>
    <content type="text"><![CDATA[java学习过程中的注意事项及与其他语言不同的地方 java开发环境的配置微信公众号：软件安装管家 学习笔记Hello Java第一个 JAVA 程序12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("Hello World"); &#125;&#125; 基本语法编写Java程序时，应注意以下几点：· 大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。 · 类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。 · 方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。 · 源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。 · 主方法入口：所有的Java 程序由public static void main(String []args)方法开始执行。 Java枚举Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的bug。1234567891011class FreshJuice &#123; enum FreshJuiceSize&#123; SMALL, MEDIUM , LARGE &#125; FreshJuiceSize size;&#125; public class FreshJuiceTest &#123; public static void main(String []args)&#123; FreshJuice juice = new FreshJuice(); juice.size = FreshJuice.FreshJuiceSize.MEDIUM ; &#125;&#125; 内置数据类型Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。byte： byte 数据类型是8位、有符号的，以二进制补码表示的整数； 最小值是 -128（-2^7）； 最大值是 127（2^7-1）； 默认值是 0； byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一； 例子：byte a = 100，byte b = -50。 short： short 数据类型是 16 位、有符号的以二进制补码表示的整数 最小值是 -32768（-2^15）； 最大值是 32767（2^15 - 1）； Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一； 默认值是 0； 例子：short s = 1000，short r = -20000。 int： int 数据类型是32位、有符号的以二进制补码表示的整数； 最小值是 -2,147,483,648（-2^31）； 最大值是 2,147,483,647（2^31 - 1）； 一般地整型变量默认为 int 类型； 默认值是 0 ； 例子：int a = 100000, int b = -200000。 long： long 数据类型是 64 位、有符号的以二进制补码表示的整数； 最小值是 -9,223,372,036,854,775,808（-2^63）； 最大值是 9,223,372,036,854,775,807（2^63 -1）； 这种类型主要使用在需要比较大整数的系统上； 默认值是 0L； 例子： long a = 100000L，Long b = -200000L。“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。 float： float 数据类型是单精度、32位、符合IEEE 754标准的浮点数； float 在储存大型浮点数组的时候可节省内存空间； 默认值是 0.0f； 浮点数不能用来表示精确的值，如货币； 例子：float f1 = 234.5f。 double： double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数； 浮点数的默认类型为double类型； double类型同样不能表示精确的值，如货币； 默认值是 0.0d； 例子：double d1 = 123.4。 boolean： boolean数据类型表示一位的信息； 只有两个取值：true 和 false； 这种类型只作为一种标志来记录 true/false 情况； 默认值是 false； 例子：boolean one = true。 char： char类型是一个单一的 16 位 Unicode 字符； 最小值是 \u0000 （即为0）； 最大值是 \uffff （即为65,535）； char 数据类型可以储存任何字符； 例子：char letter = ‘A’;。 实例123456789101112131415161718192021public class PrimitiveTypeTest &#123; public static void main(String[] args) &#123; // byte System.out.println("基本类型：byte 二进制位数：" + Byte.SIZE); System.out.println("包装类：java.lang.Byte"); System.out.println("最小值：Byte.MIN_VALUE=" + Byte.MIN_VALUE); System.out.println("最大值：Byte.MAX_VALUE=" + Byte.MAX_VALUE); System.out.println(); //其他类型略 // char System.out.println("基本类型：char 二进制位数：" + Character.SIZE); System.out.println("包装类：java.lang.Character"); // 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台 System.out.println("最小值：Character.MIN_VALUE=" + (int) Character.MIN_VALUE); // 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台 System.out.println("最大值：Character.MAX_VALUE=" + (int) Character.MAX_VALUE); &#125; &#125; 自动类型转换整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。 转换从低级到高级。 低 ————————————&gt; 高byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double 必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。 实例public class ZiDongLeiZhuan{ public static void main(String[] args){ char c1=&apos;a&apos;;//定义一个char类型 int i1 = c1;//char自动类型转换为int System.out.println(&quot;char自动类型转换为int后的值等于&quot;+i1); char c2 = &apos;A&apos;;//定义一个char类型 int i2 = c2+1;//char 类型和 int 类型计算 System.out.println(&quot;char类型和int计算后的值等于&quot;+i2); } } 运行结果为:char自动类型转换为int后的值等于97char类型和int计算后的值等于66解析：c1 的值为字符 a ,查 ASCII 码表可知对应的 int 类型值为 97， A 对应值为 65，所以 i2=65+1=66。 Java 变量类型Java语言支持的变量类型有： 类变量：独立于方法之外的变量，用 static 修饰。 实例变量：独立于方法之外的变量，不过没有 static 修饰。 局部变量：类的方法中的变量。局部变量 局部变量声明在方法、构造方法或者语句块中； 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁； 访问修饰符不能用于局部变量； 局部变量只在声明它的方法、构造方法或者语句块中可见； 局部变量是在栈上分配的。 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 实例变量 实例变量声明在一个类中，但在方法、构造方法和语句块之外； 当一个对象被实例化之后，每个实例变量的值就跟着确定； 实例变量在对象创建的时候创建，在对象被销毁的时候销毁； 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息； 实例变量可以声明在使用前或者使用后； 访问修饰符可以修饰实例变量； 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见； 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定； 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。类变量（静态变量） 类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。 静态变量在第一次被访问时创建，在程序结束时销毁。 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。 静态变量可以通过：ClassName.VariableName的方式访问。 类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。 非访问修饰符为了实现一些其他的功能，Java 也提供了许多非访问修饰符。 static 修饰符，用来修饰类方法和类变量。 final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 abstract 修饰符，用来创建抽象类和抽象方法。 synchronized 和 volatile 修饰符，主要用于线程的编程。 static 修饰符 静态变量： static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。 静态方法： static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。 对类变量和方法的访问可以直接使用 classname.variablename 和 classname.methodname 的方式访问。 final 修饰符final 变量： final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。 final 修饰符通常和 static 修饰符一起使用来创建类常量。 final 方法 类中的 final 方法可以被子类继承，但是不能被子类修改。 声明 final 方法的主要目的是防止该方法的内容被修改。 final 类 final 类不能被继承，没有类能够继承 final 类的任何特性。 abstract 修饰符抽象类： 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。 一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。 抽象类可以包含抽象方法和非抽象方法。 抽象方法 抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。 抽象方法不能被声明成 final 和 static。 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 抽象方法的声明以分号结尾，例如：public abstract sample();。 位运算符Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。 位运算符作用在所有的位上，并且按位运算。假设a = 60，b = 13;它们的二进制格式表示将如下： 1234567A = 0011 1100B = 0000 1101-----------------A&amp;b = 0000 1100A | B = 0011 1101A ^ B = 0011 0001~A= 1100 0011 下表列出了位运算符的基本运算,假设整数变量A的值为60和变量B的值为13： 操作符 描述 例子 ＆ 如果相对应位都是1，则结果为1，否则为0 （A＆B），得到12，即0000 1100 &#124; 如果相对应位都是0，则结果为0，否则为1 （A &#124;B）得到61，即 0011 1101 ^ 如果相对应位值相同，则结果为0，否则为1 （A ^ B）得到49，即 0011 0001 〜 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。 （〜A）得到-61，即1100 0011 &lt;&lt; 按位左移运算符。左操作数按位左移右操作数指定的位数。 A &lt;&lt; 2得到240，即 1111 0000 &gt;&gt; 按位右移运算符。左操作数按位右移右操作数指定的位数。 A &gt;&gt; 2得到15即 1111 &gt;&gt;&gt; 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 A&gt;&gt;&gt;2得到15即0000 1111 实例123456789101112131415161718192021222324252627public class Test &#123; public static void main(String[] args) &#123; int a = 60; /* 60 = 0011 1100 */ int b = 13; /* 13 = 0000 1101 */ int c = 0; c = a &amp; b; /* 12 = 0000 1100 */ System.out.println("a &amp; b = " + c ); c = a | b; /* 61 = 0011 1101 */ System.out.println("a | b = " + c ); c = a ^ b; /* 49 = 0011 0001 */ System.out.println("a ^ b = " + c ); c = ~a; /*-61 = 1100 0011 */ System.out.println("~a = " + c ); c = a &lt;&lt; 2; /* 240 = 1111 0000 */ System.out.println("a &lt;&lt; 2 = " + c ); c = a &gt;&gt; 2; /* 15 = 1111 */ System.out.println("a &gt;&gt; 2 = " + c ); c = a &gt;&gt;&gt; 2; /* 15 = 0000 1111 */ System.out.println("a &gt;&gt;&gt; 2 = " + c ); &#125;&#125; 以上实例编译运行结果如下： 1234567a &amp; b = 12a | b = 61a ^ b = 49~a = -61a &lt;&lt; 2 = 240a &gt;&gt; 2 = 15a &gt;&gt;&gt; 2 = 15 instanceof 运算符该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。 instanceof运算符使用格式如下： 1( Object reference variable ) instanceof (class/interface type) 如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。 下面是一个例子： 12String name = &quot;James&quot;;boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真 如果被比较的对象兼容于右侧类型,该运算符仍然返回true。 Java运算符优先级下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。 类别 操作符 关联性 后缀 () [] . (点操作符) 左到右 一元 + + - ！〜 从右到左 乘性 * /％ 左到右 加性 + - 左到右 移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 左到右 关系 &gt;&gt; = &lt;&lt; = 左到右 相等 == != 左到右 按位与 ＆ 左到右 按位异或 ^ 左到右 按位或 &#124; 左到右 逻辑与 &amp;&amp; 左到右 逻辑或 &#124; &#124; 左到右 条件 ？： 从右到左 赋值 = + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = &amp;#124 = 从右到左 逗号 ， 左到右 ava 增强 for 循环Java5 引入了一种主要用于数组的增强型 for 循环。 Java 增强 for 循环语法格式如下: for(声明语句 : 表达式) { //代码句子 } 声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。 表达式：表达式是要访问的数组名，或者是返回值为数组的方法。 实例12345678910111213141516public class Test &#123; public static void main(String args[])&#123; int [] numbers = &#123;10, 20, 30, 40, 50&#125;; for(int x : numbers )&#123; System.out.print( x ); System.out.print(","); &#125; System.out.print("\n"); String [] names =&#123;"James", "Larry", "Tom", "Lacy"&#125;; for( String name : names ) &#123; System.out.print( name ); System.out.print(","); &#125; &#125;&#125; 以上实例编译运行结果如下： 1210,20,30,40,50,James,Larry,Tom,Lacy, Java switch case 语句语法switch case 语句语法格式如下：1234567891011switch(expression)&#123; case value : //语句 break; //可选 case value : //语句 break; //可选 //你可以有任意数量的case语句 default : //可选 //语句&#125; 注意 如果 case 语句块中没有 break 语句时，JVM 并不会顺序输出每一个 case 对应的返回值，而是继续匹配，匹配不成功则返回默认 case。 如果 case 语句块中没有 break 语句时，匹配成功后，从当前 case 开始，后续所有 case 的值都会输出。 如果当前匹配成功的 case 语句块没有 break 语句，则从当前 case 开始，后续所有 case 的值都会输出，如果后续的 case 语句块有 break 语句则会跳出判断。 Java Number 类 Java 语言为每一个内置数据类型提供了对应的包装类。所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。 这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。 实例：12345678public class Test&#123; public static void main(String args[])&#123; Integer x = 5; x = x + 10; System.out.println(x); &#125;&#125; 以上实例编译运行结果如下：115 Java Math 类 Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。 实例1234567891011public class Test &#123; public static void main (String []args) &#123; System.out.println("90 度的正弦值：" + Math.sin(Math.PI/2)); System.out.println("0度的余弦值：" + Math.cos(0)); System.out.println("60度的正切值：" + Math.tan(Math.PI/3)); System.out.println("1的反正切值： " + Math.atan(1)); System.out.println("π/2的角度值：" + Math.toDegrees(Math.PI/2)); System.out.println(Math.PI); &#125; &#125; 以上实例编译运行结果如下：12345690 度的正弦值：1.00度的余弦值：1.060度的正切值：1.73205080756887671的反正切值： 0.7853981633974483π/2的角度值：90.03.141592653589793 Number &amp; Math 类方法下面的表中列出的是 Number &amp; Math 类常用的一些方法： 序号 方法与描述 1 xxxValue() 将 Number 对象转换为xxx数据类型的值并返回。 2 compareTo() 将number对象与参数比较。 3 equals() 判断number对象是否与参数相等。 4 valueOf() 返回一个 Number 对象指定的内置数据类型 5 toString() 以字符串形式返回值。 6 parseInt() 将字符串解析为int类型。 7 abs() 返回参数的绝对值。 8 ceil() 返回大于等于( &gt;= )给定参数的的最小整数，类型为双精度浮点型。 9 floor() 返回小于等于（&lt;=）给定参数的最大整数 。 10 rint() 返回与参数最接近的整数。返回类型为double。 11 round() 它表示四舍五入，算法为 Math.floor(x+0.5)，即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5) 的结果为12，Math.round(-11.5) 的结果为-11。 12 min() 返回两个参数中的最小值。 13 max() 返回两个参数中的最大值。 14 exp() 返回自然数底数e的参数次方。 15 log() 返回参数的自然数底数的对数值。 16 pow() 返回第一个参数的第二个参数次方。 17 sqrt() 求参数的算术平方根。 18 sin() 求指定double类型参数的正弦值。 19 cos() 求指定double类型参数的余弦值。 20 tan() 求指定double类型参数的正切值。 21 asin() 求指定double类型参数的反正弦值。 22 acos() 求指定double类型参数的反余弦值。 23 atan() 求指定double类型参数的反正切值。 24 atan2() 将笛卡尔坐标转换为极坐标，并返回极坐标的角度值。 25 toDegrees() 将参数转化为角度。 26 toRadians() 将角度转换为弧度。 27 random() 返回一个随机数。 Java Character 类 Character 类用于对单个字符进行操作。Character 类在对象中包装一个基本类型 char 的值 Character 方法下面是Character类的方法： 序号 方法与描述 1 isLetter() 是否是一个字母 2 isDigit() 是否是一个数字字符 3 isWhitespace() 是否是一个空白字符 4 isUpperCase() 是否是大写字母 5 isLowerCase() 是否是小写字母 6 toUpperCase() 指定字母的大写形式 7 toLowerCase() 指定字母的小写形式 8 toString() 返回字符的字符串形式，字符串的长度仅为1 Java String 类 字符串广泛应用 在Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。注意: String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了（详看笔记部分解析）。如果需要对字符串做很多修改，那么应该选择使用 StringBuffer &amp; StringBuilder 类。 创建格式化字符串 我们知道输出格式化数字可以使用 printf() 和 format() 方法。 String 类使用静态方法 format() 返回一个String 对象而不是 PrintStream 对象。 String 类的静态方法 format() 能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。 实例1234System.out.printf("浮点型变量的值为 " + "%f, 整型变量的值为 " + " %d, 字符串变量的值为 " + "is %s", floatVar, intVar, stringVar); 12345String fs;fs = String.format("浮点型变量的值为 " + "%f, 整型变量的值为 " + " %d, 字符串变量的值为 " + " %s", floatVar, intVar, stringVar); String 方法 下面是 String 类支持的方法 SN(序号) 方法描述 1 char charAt(int index) 返回指定索引处的 char 值。 2 int compareTo(Object o) 把这个字符串和另一个对象比较。 3 int compareTo(String anotherString) 按字典顺序比较两个字符串。 4 int compareToIgnoreCase(String str) 按字典顺序比较两个字符串，不考虑大小写。 5 String concat(String str) 将指定字符串连接到此字符串的结尾。 6 boolean contentEquals(StringBuffer sb) 当且仅当字符串与指定的StringBuffer有相同顺序的字符时候返回真。 7 static String copyValueOf(char[] data) 返回指定数组中表示该字符序列的 String。 8 static String copyValueOf(char[] data, int offset, int count) 返回指定数组中表示该字符序列的 String。 9 boolean endsWith(String suffix) 测试此字符串是否以指定的后缀结束。 10 boolean equals(Object anObject) 将此字符串与指定的对象比较。 11 boolean equalsIgnoreCase(String anotherString) 将此 String 与另一个 String 比较，不考虑大小写。 12 byte[] getBytes() 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 13 byte[] getBytes(String charsetName) 使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 14 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此字符串复制到目标字符数组。 15 int hashCode() 返回此字符串的哈希码。 16 int indexOf(int ch) 返回指定字符在此字符串中第一次出现处的索引。 17 int indexOf(int ch, int fromIndex) 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。 18 int indexOf(String str) 返回指定子字符串在此字符串中第一次出现处的索引。 19 int indexOf(String str, int fromIndex) 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。 20 String intern() 返回字符串对象的规范化表示形式。 21 int lastIndexOf(int ch) 返回指定字符在此字符串中最后一次出现处的索引。 22 int lastIndexOf(int ch, int fromIndex) 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。 23 int lastIndexOf(String str) 返回指定子字符串在此字符串中最右边出现处的索引。 24 int lastIndexOf(String str, int fromIndex) 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。 25 int length() 返回此字符串的长度。 26 boolean matches(String regex) 告知此字符串是否匹配给定的正则表达式。 27 boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) 测试两个字符串区域是否相等。 28 boolean regionMatches(int toffset, String other, int ooffset, int len) 测试两个字符串区域是否相等。 29 String replace(char oldChar, char newChar) 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 30 String replaceAll(String regex, String replacement) 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 31 String replaceFirst(String regex, String replacement) 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 32 String[] split(String regex) 根据给定正则表达式的匹配拆分此字符串。 33 String[] split(String regex, int limit) 根据匹配给定的正则表达式来拆分此字符串。 34 boolean startsWith(String prefix) 测试此字符串是否以指定的前缀开始。 35 boolean startsWith(String prefix, int toffset) 测试此字符串从指定索引开始的子字符串是否以指定前缀开始。 36 CharSequence subSequence(int beginIndex, int endIndex) 返回一个新的字符序列，它是此序列的一个子序列。 37 String substring(int beginIndex) 返回一个新的字符串，它是此字符串的一个子字符串。 38 String substring(int beginIndex, int endIndex) 返回一个新字符串，它是此字符串的一个子字符串。 39 char[] toCharArray() 将此字符串转换为一个新的字符数组。 40 String toLowerCase() 使用默认语言环境的规则将此 String 中的所有字符都转换为小写。 41 String toLowerCase(Locale locale) 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。 42 String toString() 返回此对象本身（它已经是一个字符串！）。 43 String toUpperCase() 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。 44 String toUpperCase(Locale locale) 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。 45 String trim() 返回字符串的副本，忽略前导空白和尾部空白。 46 static String valueOf(primitive data type x) 返回给定data type类型x参数的字符串表示形式。 Java StringBuffer 和 StringBuilder 类 当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。 和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。 实例123456789public class Test&#123; public static void main(String args[])&#123; StringBuffer sBuffer = new StringBuffer("菜鸟教程官网："); sBuffer.append("www"); sBuffer.append(".runoob"); sBuffer.append(".com"); System.out.println(sBuffer); &#125;&#125; StringBuffer 方法以下是 StringBuffer 类支持的主要方法： 序号 方法描述 1 public StringBuffer append(String s) 将指定的字符串追加到此字符序列。 2 public StringBuffer reverse() 将此字符序列用其反转形式取代。 3 public delete(int start, int end) 移除此序列的子字符串中的字符。 4 public insert(int offset, int i) 将 int 参数的字符串表示形式插入此序列中。 5 replace(int start, int end, String str) 使用给定 String 中的字符替换此序列的子字符串中的字符。 下面的列表里的方法和 String 类的方法类似： 序号 方法描述 1 int capacity() 返回当前容量。 2 char charAt(int index) 返回此序列中指定索引处的 char 值。 3 void ensureCapacity(int minimumCapacity) 确保容量至少等于指定的最小值。 4 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此序列复制到目标字符数组 dst。 5 int indexOf(String str) 返回第一次出现的指定子字符串在该字符串中的索引。 6 int indexOf(String str, int fromIndex) 从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。 7 int lastIndexOf(String str) 返回最右边出现的指定子字符串在此字符串中的索引。 8 int lastIndexOf(String str, int fromIndex) 返回 String 对象中子字符串最后出现的位置。 9 int length() 返回长度（字符数）。 10 void setCharAt(int index, char ch) 将给定索引处的字符设置为 ch。 11 void setLength(int newLength) 设置字符序列的长度。 12 CharSequence subSequence(int start, int end) 返回一个新的字符序列，该字符序列是此序列的子序列。 13 String substring(int start) 返回一个新的 String，它包含此字符序列当前所包含的字符子序列。 14 String substring(int start, int end) 返回一个新的 String，它包含此序列当前所包含的字符子序列。 15 String toString() 返回此序列中数据的字符串表示形式。 Java 数组声明数组变量1dataType[] arrayRefVar; // 首选的方法 创建数组1arrayRefVar = new dataType[arraySize]; For-Each 循环 JDK 1.5 引进了一种新的循环类型，被称为 For-Each 循环或者加强型循环，它能在不使用下标的情况下遍历数组。 语法格式如下：1234for(type element: array)&#123; System.out.println(element);&#125; 实例12345678910public class TestArray &#123; public static void main(String[] args) &#123; double[] myList = &#123;1.9, 2.9, 3.4, 3.5&#125;; // 打印所有数组元素 for (double element: myList) &#123; System.out.println(element); &#125; &#125;&#125; Arrays 类java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。 具有以下功能： 给数组赋值：通过 fill 方法。 对数组排序：通过 sort 方法,按升序。 比较数组：通过 equals 方法比较数组中元素值是否相等。 查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。 具体说明请查看下表： 序号 方法和说明 1 public static int binarySearch(Object[] a, Object key) 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。 2 public static boolean equals(long[] a, long[] a2) 如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 3 public static void fill(int[] a, int val) 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 4 public static void sort(Object[] a) 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 Java 日期时间 java.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。 第一个构造函数使用当前日期和时间来初始化对象。 Date( ) 第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。 Date(long millisec) Date对象创建以后，可以调用下面的方法。 序号 方法和描述 1 boolean after(Date date) 若当调用此方法的Date对象在指定日期之后返回true,否则返回false。 2 boolean before(Date date) 若当调用此方法的Date对象在指定日期之前返回true,否则返回false。 3 Object clone( ) 返回此对象的副本。 4 int compareTo(Date date) 比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。 5 int compareTo(Object obj) 若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出ClassCastException。 6 boolean equals(Object date) 当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。 7 long getTime( ) 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 8 int hashCode( ) 返回此对象的哈希码值。 9 void setTime(long time) 用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。 10 String toString( ) 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)。 获取当日时间实例1234567891011import java.util.Date; public class DateDemo &#123; public static void main(String args[]) &#123; // 初始化 Date 对象 Date date = new Date(); // 使用 toString() 函数显示日期时间 System.out.println(date.toString()); &#125;&#125; 使用 SimpleDateFormat 格式化日期 SimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。 实例123456789101112import java.util.*;import java.text.*; public class DateDemo &#123; public static void main(String args[]) &#123; Date dNow = new Date( ); SimpleDateFormat ft = new SimpleDateFormat ("yyyy-MM-dd hh:mm:ss"); //这行代码确立了转换的格式，其中 yyyy 是完整的公元年，MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。 System.out.println("当前时间为: " + ft.format(dNow)); &#125;&#125; 运行结果` Current Date: Wed 2019.03.27 at 01:07:33 PM UTC 注意: 有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。 日期和时间的格式化编码时间模式字符串用来指定时间格式。在此模式中，所有的 ASCII 字母被保留为模式字母，定义如下： 字母 描述 示例 G 纪元标记 AD y 四位年份 2001 M 月份 July or 07 d 一个月的日期 10 h A.M./P.M. (1~12)格式小时 12 H 一天中的小时 (0~23) 22 m 分钟数 30 s 秒数 55 S 毫秒数 234 E 星期几 Tuesday D 一年中的日子 360 F 一个月中第几周的周几 2 (second Wed. in July) w 一年中第几周 40 W 一个月中第几周 1 a A.M./P.M. 标记 PM k 一天中的小时(1~24) 24 K A.M./P.M. (0~11)格式小时 10 z 时区 Eastern Standard Time ‘ 文字定界符 Delimiter “ 单引号 ` 使用printf格式化日期printf 方法可以很轻松地格式化时间和日期。使用两个字母格式，它以 %t 开头并且以下面表格中的一个字母结尾。 转 换 符 说 明 示 例 c 包括全部日期和时间信息 星期六 十月 27 14:21:20 CST 2007 F “年-月-日”格式 2007-10-27 D “月/日/年”格式 10/27/07 r “HH:MM:SS PM”格式（12时制） 02:25:51 下午 T “HH:MM:SS”格式（24时制） 14:28:16 R “HH:MM”格式（24时制） 14:28 实例12345678910111213141516171819202122import java.util.Date; public class DateDemo &#123; public static void main(String args[]) &#123; // 初始化 Date 对象 Date date = new Date(); //c的使用 System.out.printf("全部日期和时间信息：%tc%n",date); //f的使用 System.out.printf("年-月-日格式：%tF%n",date); //d的使用 System.out.printf("月/日/年格式：%tD%n",date); //r的使用 System.out.printf("HH:MM:SS PM格式（12时制）：%tr%n",date); //t的使用 System.out.printf("HH:MM:SS格式（24时制）：%tT%n",date); //R的使用 System.out.printf("HH:MM格式（24时制）：%tR",date); &#125;&#125; 以上实例编译运行结果如下: 全部日期和时间信息：星期一 九月 10 10:43:36 CST 2012年-月-日格式：2012-09-10月/日/年格式：09/10/12HH:MM:SS PM格式（12时制）：10:43:36 上午HH:MM:SS格式（24时制）：10:43:36HH:MM格式（24时制）：10:43 如果你需要重复提供日期，那么利用这种方式来格式化它的每一部分就有点复杂了。因此，可以利用一个格式化字符串指出要被格式化的参数的索引。 索引必须紧跟在%后面，而且必须以$结束。 实例1234567891011121314import java.util.Date; public class DateDemo &#123; public static void main(String args[]) &#123; // 初始化 Date 对象 Date date = new Date(); // 使用toString()显示日期和时间 System.out.printf("%1$s %2$tB %2$td, %2$tY", "Due date:", date);//%1$s对应第一个索引"Due date:"，%2$tB %2$td, %2$tY"对应第二个索引 date &#125;&#125; 以上实例编译运行结果如下: Due date: February 09, 2014 或者，你可以使用 &lt; 标志。它表明先前被格式化的参数要被再次使用。： 实例12345678910111213import java.util.Date; public class DateDemo &#123; public static void main(String args[]) &#123; // 初始化 Date 对象 Date date = new Date(); // 显示格式化时间 System.out.printf("%s %tB %&lt;te, %&lt;tY", "Due date:", date); &#125;&#125; 解析字符串为时间SimpleDateFormat 类有一些附加的方法，特别是parse()，它试图按照给定的SimpleDateFormat 对象的格式化存储来解析字符串。 实例123456789101112131415161718import java.util.*;import java.text.*; public class DateDemo &#123; public static void main(String args[]) &#123; SimpleDateFormat ft = new SimpleDateFormat ("yyyy-MM-dd-hh:mm:ss"); //这里可以修改格式 String input = "2015-11-10-23:23:20" ; System.out.print(input + " Parses as "); Date t; try &#123; t = ft.parse(input); System.out.println(t); &#125; catch (ParseException e) &#123; System.out.println("Unparseable using " + ft); &#125; &#125;&#125; 运行结果 2015-11-10-23:23:20 Parses as Tue Nov 10 23:23:20 UTC 2015 Java 休眠(sleep) sleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。你可以让程序休眠一毫秒的时间或者到您的计算机的寿命长的任意段时间。 实例12345678910111213import java.util.*; public class SleepDemo &#123; public static void main(String args[]) &#123; try &#123; System.out.println(new Date( ) + "\n"); Thread.sleep(1000*3); // 休眠3秒 System.out.println(new Date( ) + "\n"); &#125; catch (Exception e) &#123; System.out.println("Got an exception!"); &#125; &#125;&#125; 运行结果 Wed Mar 27 13:52:45 UTC 2019 Wed Mar 27 13:52:48 UTC 2019 Calendar类我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，或者分钟? 我们又如何在日期的这些部分加上或者减去值呢? 答案是使用Calendar 类。 Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些. Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。 创建一个代表系统当前日期的Calendar对象 Calendar c = Calendar.getInstance();//默认是当前日期 Calendar类对象字段类型Calendar类中用以下这些常量表示不同的意义，jdk内的很多类其实都是采用的这种思想 常量 描述 Calendar.YEAR 年份 Calendar.MONTH 月份 Calendar.DATE 日期 Calendar.DAY_OF_MONTH 日期，和上面的字段意义完全相同 Calendar.HOUR 12小时制的小时 Calendar.HOUR_OF_DAY 24小时制的小时 Calendar.MINUTE 分钟 Calendar.SECOND 秒 Calendar.DAY_OF_WEEK 星期几 Calendar类对象信息的设置Set设置 Calendar c1 = Calendar.getInstance();调用：public final void set(int year,int month,int date)c1.set(2009, 6 - 1, 12);//把Calendar对象c1的年月日分别设这为：2009、6、12如果只设定某个字段，例如日期的值，则可以使用如下set方法：public void set(int field,int value)把 c1对象代表的日期设置为10号，其它所有的数值会被重新计算c1.set(Calendar.DATE,10); Add设置 Calendar c1 = Calendar.getInstance();把c1对象的日期加上10，也就是c1也就表示为10天后的日期，其它所有的数值会被重新计算c1.add(Calendar.DATE, 10);把c1对象的日期减去10，也就是c1也就表示为10天前的日期，其它所有的数值会被重新计算c1.add(Calendar.DATE, -10); GregorianCalendar类 Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。Calendar 的getInstance（）方法返回一个默认用当前的语言环境和时区初始化的GregorianCalendar对象。GregorianCalendar定义了两个字段：AD和BC。这是代表公历定义的两个时代。 下面列出GregorianCalendar对象的几个构造方法： 序号 构造函数和说明 1 GregorianCalendar() 在具有默认语言环境的默认时区内使用当前时间构造一个默认的 GregorianCalendar。 2 GregorianCalendar(int year, int month, int date) 在具有默认语言环境的默认时区内构造一个带有给定日期设置的 GregorianCalendar 3 GregorianCalendar(int year, int month, int date, int hour, int minute) 为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。 4 GregorianCalendar(int year, int month, int date, int hour, int minute, int second) 为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。 5 GregorianCalendar(Locale aLocale) 在具有给定语言环境的默认时区内构造一个基于当前时间的 GregorianCalendar。 6 GregorianCalendar(TimeZone zone) 在具有默认语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。 7 GregorianCalendar(TimeZone zone, Locale aLocale) 在具有给定语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。 这里是GregorianCalendar 类提供的一些有用的方法列表： 序号 方法和说明 1 void add(int field, int amount) 根据日历规则，将指定的（有符号的）时间量添加到给定的日历字段中。 2 protected void computeFields() 转换UTC毫秒值为时间域值 3 protected void computeTime() 覆盖Calendar ，转换时间域值为UTC毫秒值 4 boolean equals(Object obj) 比较此 GregorianCalendar 与指定的 Object。 5 int get(int field) 获取指定字段的时间值 6 int getActualMaximum(int field) 返回当前日期，给定字段的最大值 7 int getActualMinimum(int field) 返回当前日期，给定字段的最小值 8 int getGreatestMinimum(int field) 返回此 GregorianCalendar 实例给定日历字段的最高的最小值。 9 Date getGregorianChange() 获得格里高利历的更改日期。 10 int getLeastMaximum(int field) 返回此 GregorianCalendar 实例给定日历字段的最低的最大值 11 int getMaximum(int field) 返回此 GregorianCalendar 实例的给定日历字段的最大值。 12 Date getTime() 获取日历当前时间。 13 long getTimeInMillis() 获取用长整型表示的日历的当前时间 14 TimeZone getTimeZone() 获取时区。 15 int getMinimum(int field) 返回给定字段的最小值。 16 int hashCode() 重写hashCode. 17 boolean isLeapYear(int year) 确定给定的年份是否为闰年。 18 void roll(int field, boolean up) 在给定的时间字段上添加或减去（上/下）单个时间单元，不更改更大的字段。 19 void set(int field, int value) 用给定的值设置时间字段。 20 void set(int year, int month, int date) 设置年、月、日的值。 21 void set(int year, int month, int date, int hour, int minute) 设置年、月、日、小时、分钟的值。 22 void set(int year, int month, int date, int hour, int minute, int second) 设置年、月、日、小时、分钟、秒的值。 23 void setGregorianChange(Date date) 设置 GregorianCalendar 的更改日期。 24 void setTime(Date date) 用给定的日期设置Calendar的当前时间。 25 void setTimeInMillis(long millis) 用给定的long型毫秒数设置Calendar的当前时间。 26 void setTimeZone(TimeZone value) 用给定时区值设置当前时区。 27 String toString() 返回代表日历的字符串。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客：在Github上搭建Hexo博客]]></title>
    <url>%2F2019%2F03%2F23%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[具体实现看下面的链接 这里是一些链接，请享用~ Github上搭建Hexo博客 next主题视频教程 next主题安装及其设置 GitHub Corners 三月里的樱花已经悄然开放，开的如火如荼，极其美丽。翠绿的枝叶，沾有清晨的露珠，在太阳慈爱的照耀下闪闪发亮。满树烂漫的樱花林，透出了一股甜美的气息。从远处看，如云似霞般炫目，不时引来一只只彩蝶绕花盘旋，花掩蝶蝶恋花，两种景物融为一体，时常迷得依依抱着胳膊趴在树枝上暗暗陶醉。]]></content>
      <categories>
        <category>安装链接</category>
      </categories>
      <tags>
        <tag>搭建hexo博客</tag>
        <tag>next主题安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
